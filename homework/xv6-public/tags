!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALT	kbd.h	11;"	d
AS	Makefile	/^AS = $(TOOLPREFIX)gas$/;"	m
ASFLAGS	Makefile	/^ASFLAGS = -m32 -gdwarf-2 -Wa,-divide$/;"	m
ASSERT	lapic.c	25;"	d	file:
Align	umalloc.c	/^typedef long Align;$/;"	t	file:
BACK	sh.c	12;"	d	file:
BACKSPACE	console.c	127;"	d	file:
BBLOCK	fs.h	50;"	d
BBLOCK	fs_bak.h	48;"	d
BCAST	lapic.c	28;"	d	file:
BIG	usertests.c	1452;"	d	file:
BPB	fs.h	47;"	d
BPB	fs_bak.h	45;"	d
BSIZE	fs.h	6;"	d
BSIZE	fs_bak.h	6;"	d
BUSY	lapic.c	29;"	d	file:
B_DIRTY	buf.h	13;"	d
B_VALID	buf.h	12;"	d
C	console.c	189;"	d	file:
C	kbd.h	32;"	d
CAPSLOCK	kbd.h	13;"	d
CC	Makefile	/^CC = $(TOOLPREFIX)gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer$/;"	m
CMOS_PORT	lapic.c	123;"	d	file:
CMOS_RETURN	lapic.c	124;"	d	file:
CMOS_STATA	lapic.c	163;"	d	file:
CMOS_STATB	lapic.c	164;"	d	file:
CMOS_UIP	lapic.c	165;"	d	file:
COM1	uart.c	15;"	d	file:
CONSOLE	file.h	37;"	d
CONSOLE	file_bak.h	37;"	d
CONV	lapic.c	217;"	d	file:
CONV	lapic.c	224;"	d	file:
CPUS	Makefile	/^CPUS := 1$/;"	m
CR0_PE	mmu.h	8;"	d
CR0_PG	mmu.h	10;"	d
CR0_WP	mmu.h	9;"	d
CR4_PSE	mmu.h	12;"	d
CRTPORT	console.c	128;"	d	file:
CTL	kbd.h	10;"	d
DAY	lapic.c	170;"	d	file:
DEASSERT	lapic.c	26;"	d	file:
DELIVS	lapic.c	24;"	d	file:
DEVSPACE	memlayout.h	5;"	d
DIRSIZ	fs.h	53;"	d
DIRSIZ	fs_bak.h	51;"	d
DPL_USER	mmu.h	53;"	d
E0ESC	kbd.h	17;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	elf.h	37;"	d
EMBRYO	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
ENABLE	lapic.c	19;"	d	file:
EOI	lapic.c	17;"	d	file:
ERROR	lapic.c	38;"	d	file:
ESR	lapic.c	20;"	d	file:
EXEC	sh.c	8;"	d	file:
EXTMEM	memlayout.h	3;"	d
EXTRA	Makefile	/^EXTRA=\\$/;"	m
FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon8
FD_INODE	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon8
FD_NONE	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon8
FD_PIPE	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
FILES	Makefile	/^FILES = $(shell grep -v '^\\#' runoff.list)$/;"	m
FIXED	lapic.c	30;"	d	file:
FL_IF	mmu.h	5;"	d
FREE	uthread.c	6;"	d	file:
FSSIZE	param.h	13;"	d
GDBPORT	Makefile	/^GDBPORT = $(shell expr `id -u` % 5000 + 25000)$/;"	m
HOURS	lapic.c	169;"	d	file:
Header	umalloc.c	/^typedef union header Header;$/;"	t	typeref:union:header	file:
IBLOCK	fs.h	44;"	d
IBLOCK	fs_bak.h	42;"	d
ICRHI	lapic.c	31;"	d	file:
ICRLO	lapic.c	21;"	d	file:
ID	lapic.c	14;"	d	file:
IDE_BSY	ide.c	17;"	d	file:
IDE_CMD_RDMUL	ide.c	24;"	d	file:
IDE_CMD_READ	ide.c	22;"	d	file:
IDE_CMD_WRITE	ide.c	23;"	d	file:
IDE_CMD_WRMUL	ide.c	25;"	d	file:
IDE_DF	ide.c	19;"	d	file:
IDE_DRDY	ide.c	18;"	d	file:
IDE_ERR	ide.c	20;"	d	file:
INIT	lapic.c	22;"	d	file:
INPUT_BUF	console.c	181;"	d	file:
INT_ACTIVELOW	ioapic.c	22;"	d	file:
INT_DISABLED	ioapic.c	20;"	d	file:
INT_LEVEL	ioapic.c	21;"	d	file:
INT_LOGICAL	ioapic.c	23;"	d	file:
IOAPIC	ioapic.c	9;"	d	file:
IO_PIC1	picirq.c	6;"	d	file:
IO_PIC2	picirq.c	7;"	d	file:
IPB	fs.h	41;"	d
IPB	fs_bak.h	39;"	d
IRQ_COM1	traps.h	34;"	d
IRQ_ERROR	traps.h	36;"	d
IRQ_IDE	traps.h	35;"	d
IRQ_KBD	traps.h	33;"	d
IRQ_SPURIOUS	traps.h	37;"	d
IRQ_TIMER	traps.h	32;"	d
KBDATAP	kbd.h	5;"	d
KBSTATP	kbd.h	3;"	d
KBS_DIB	kbd.h	4;"	d
KERNBASE	memlayout.h	8;"	d
KERNLINK	memlayout.h	9;"	d
KEY_DEL	kbd.h	29;"	d
KEY_DN	kbd.h	23;"	d
KEY_END	kbd.h	21;"	d
KEY_HOME	kbd.h	20;"	d
KEY_INS	kbd.h	28;"	d
KEY_LF	kbd.h	24;"	d
KEY_PGDN	kbd.h	27;"	d
KEY_PGUP	kbd.h	26;"	d
KEY_RT	kbd.h	25;"	d
KEY_UP	kbd.h	22;"	d
KSTACKSIZE	param.h	2;"	d
LD	Makefile	/^LD = $(TOOLPREFIX)ld$/;"	m
LEVEL	lapic.c	27;"	d	file:
LINT0	lapic.c	36;"	d	file:
LINT1	lapic.c	37;"	d	file:
LIST	sh.c	11;"	d	file:
LOGSIZE	param.h	11;"	d
MASKED	lapic.c	39;"	d	file:
MAXARG	param.h	9;"	d
MAXARGS	sh.c	14;"	d	file:
MAXFILE	fs.h	27;"	d
MAXFILE	fs_bak.h	26;"	d
MAXOPBLOCKS	param.h	10;"	d
MAX_THREAD	uthread.c	11;"	d	file:
MEMFSOBJS	Makefile	/^MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o$/;"	m
MINS	lapic.c	168;"	d	file:
MONTH	lapic.c	171;"	d	file:
MPBOOT	mp.h	34;"	d
MPBUS	mp.h	50;"	d
MPIOAPIC	mp.h	51;"	d
MPIOINTR	mp.h	52;"	d
MPLINTR	mp.h	53;"	d
MPPROC	mp.h	49;"	d
N	forktest.c	8;"	d	file:
NBUF	param.h	12;"	d
NCPU	param.h	3;"	d
NDEV	param.h	7;"	d
NDINDIRECT	fs.h	26;"	d
NDIRECT	fs.h	24;"	d
NDIRECT	fs_bak.h	24;"	d
NELEM	defs.h	190;"	d
NFILE	param.h	5;"	d
NINDIRECT	fs.h	25;"	d
NINDIRECT	fs_bak.h	25;"	d
NINODE	param.h	6;"	d
NINODES	mkfs.c	18;"	d	file:
NO	kbd.h	7;"	d
NOFILE	param.h	4;"	d
NPDENTRIES	mmu.h	83;"	d
NPROC	param.h	1;"	d
NPTENTRIES	mmu.h	84;"	d
NSEGS	mmu.h	22;"	d
NUMLOCK	kbd.h	14;"	d
OBJCOPY	Makefile	/^OBJCOPY = $(TOOLPREFIX)objcopy$/;"	m
OBJDUMP	Makefile	/^OBJDUMP = $(TOOLPREFIX)objdump$/;"	m
OBJS	Makefile	/^OBJS = \\$/;"	m
O_CREATE	fcntl.h	4;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	fcntl.h	3;"	d
O_WRONLY	fcntl.h	2;"	d
P2V	memlayout.h	12;"	d
P2V_WO	memlayout.h	15;"	d
PCINT	lapic.c	35;"	d	file:
PDX	mmu.h	74;"	d
PDXSHIFT	mmu.h	88;"	d
PERIODIC	lapic.c	34;"	d	file:
PGADDR	mmu.h	80;"	d
PGROUNDDOWN	mmu.h	91;"	d
PGROUNDUP	mmu.h	90;"	d
PGSIZE	mmu.h	85;"	d
PHYSTOP	memlayout.h	4;"	d
PIPE	sh.c	10;"	d	file:
PIPESIZE	pipe.c	11;"	d	file:
PRINT	Makefile	/^PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)$/;"	m
PTE_ADDR	mmu.h	100;"	d
PTE_FLAGS	mmu.h	101;"	d
PTE_P	mmu.h	94;"	d
PTE_PS	mmu.h	97;"	d
PTE_U	mmu.h	96;"	d
PTE_W	mmu.h	95;"	d
PTX	mmu.h	77;"	d
PTXSHIFT	mmu.h	87;"	d
QEMU	Makefile	/^QEMU = $(shell if which qemu > \/dev\/null; \\$/;"	m
QEMUEXTRA	Makefile	/^QEMUEXTRA = $/;"	m
QEMUGDB	Makefile	/^QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\$/;"	m
QEMUOPTS	Makefile	/^QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)$/;"	m
REDIR	sh.c	9;"	d	file:
REG_ID	ioapic.c	11;"	d	file:
REG_TABLE	ioapic.c	13;"	d	file:
REG_VER	ioapic.c	12;"	d	file:
ROOTDEV	param.h	8;"	d
ROOTINO	fs.h	5;"	d
ROOTINO	fs_bak.h	5;"	d
RTC_ADDR	usertests.c	1701;"	d	file:
RTC_DATA	usertests.c	1702;"	d	file:
RUNNABLE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNABLE	uthread.c	8;"	d	file:
RUNNING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	uthread.c	7;"	d	file:
SCROLLLOCK	kbd.h	15;"	d
SECS	lapic.c	167;"	d	file:
SECTOR_SIZE	ide.c	16;"	d	file:
SECTSIZE	bootmain.c	13;"	d	file:
SEG	mmu.h	43;"	d
SEG16	mmu.h	47;"	d
SEG_ASM	asm.h	11;"	d
SEG_KCODE	mmu.h	15;"	d
SEG_KDATA	mmu.h	16;"	d
SEG_NULLASM	asm.h	5;"	d
SEG_TSS	mmu.h	19;"	d
SEG_UCODE	mmu.h	17;"	d
SEG_UDATA	mmu.h	18;"	d
SETGATE	mmu.h	168;"	d
SHIFT	kbd.h	9;"	d
SLEEPING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
STACK_SIZE	uthread.c	10;"	d	file:
STARTUP	lapic.c	23;"	d	file:
STA_R	asm.h	18;"	d
STA_R	mmu.h	58;"	d
STA_W	asm.h	17;"	d
STA_W	mmu.h	57;"	d
STA_X	asm.h	16;"	d
STA_X	mmu.h	56;"	d
STS_IG32	mmu.h	62;"	d
STS_T32A	mmu.h	61;"	d
STS_TG32	mmu.h	63;"	d
SVR	lapic.c	18;"	d	file:
SYSCALL	usys.S	/^#define SYSCALL(name) \\$/;"	d
SYS_alarm	syscall.h	24;"	d
SYS_chdir	syscall.h	10;"	d
SYS_close	syscall.h	22;"	d
SYS_date	syscall.h	23;"	d
SYS_dup	syscall.h	11;"	d
SYS_exec	syscall.h	8;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	syscall.h	9;"	d
SYS_getpid	syscall.h	12;"	d
SYS_kill	syscall.h	7;"	d
SYS_link	syscall.h	20;"	d
SYS_mkdir	syscall.h	21;"	d
SYS_mknod	syscall.h	18;"	d
SYS_open	syscall.h	16;"	d
SYS_pipe	syscall.h	5;"	d
SYS_read	syscall.h	6;"	d
SYS_sbrk	syscall.h	13;"	d
SYS_sleep	syscall.h	14;"	d
SYS_unlink	syscall.h	19;"	d
SYS_uptime	syscall.h	15;"	d
SYS_wait	syscall.h	4;"	d
SYS_write	syscall.h	17;"	d
TCCR	lapic.c	41;"	d	file:
TDCR	lapic.c	42;"	d	file:
TICR	lapic.c	40;"	d	file:
TIMER	lapic.c	32;"	d	file:
TOOLPREFIX	Makefile	/^TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
TPR	lapic.c	16;"	d	file:
T_ALIGN	traps.h	21;"	d
T_BOUND	traps.h	9;"	d
T_BRKPT	traps.h	7;"	d
T_DBLFLT	traps.h	12;"	d
T_DEBUG	traps.h	5;"	d
T_DEFAULT	traps.h	28;"	d
T_DEV	stat.h	3;"	d
T_DEVICE	traps.h	11;"	d
T_DIR	stat.h	1;"	d
T_DIVIDE	traps.h	4;"	d
T_FILE	stat.h	2;"	d
T_FPERR	traps.h	20;"	d
T_GPFLT	traps.h	17;"	d
T_ILLOP	traps.h	10;"	d
T_IRQ0	traps.h	30;"	d
T_MCHK	traps.h	22;"	d
T_NMI	traps.h	6;"	d
T_OFLOW	traps.h	8;"	d
T_PGFLT	traps.h	18;"	d
T_SEGNP	traps.h	15;"	d
T_SIMDERR	traps.h	23;"	d
T_STACK	traps.h	16;"	d
T_SYSCALL	traps.h	27;"	d
T_TSS	traps.h	14;"	d
ULIB	Makefile	/^ULIB = ulib.o usys.o printf.o umalloc.o$/;"	m
UNUSED	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
UPROGS	Makefile	/^UPROGS=\\$/;"	m
V2P	memlayout.h	11;"	d
V2P_WO	memlayout.h	14;"	d
VER	lapic.c	15;"	d	file:
X1	lapic.c	33;"	d	file:
YEAR	lapic.c	172;"	d	file:
ZOMBIE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
__anon10::inode	fs_bak.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon10	typeref:struct:__anon10::inode	file:	access:public
__anon10::lock	fs_bak.c	/^  struct spinlock lock;$/;"	m	struct:__anon10	typeref:struct:__anon10::spinlock	file:	access:public
__anon11::inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon11	typeref:struct:__anon11::inode	file:	access:public
__anon11::lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon11	typeref:struct:__anon11::spinlock	file:	access:public
__anon1::freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon1	typeref:struct:__anon1::run	file:	access:public
__anon1::lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:	access:public
__anon1::use_lock	kalloc.c	/^  int use_lock;$/;"	m	struct:__anon1	file:	access:public
__anon2::lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:	access:public
__anon2::locking	console.c	/^  int locking;$/;"	m	struct:__anon2	file:	access:public
__anon3::buf	console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon3	file:	access:public
__anon3::e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon3	file:	access:public
__anon3::r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon3	file:	access:public
__anon3::w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon3	file:	access:public
__anon4::lock	proc.c	/^  struct spinlock lock;$/;"	m	struct:__anon4	typeref:struct:__anon4::spinlock	file:	access:public
__anon4::proc	proc.c	/^  struct proc proc[NPROC];$/;"	m	struct:__anon4	typeref:struct:__anon4::proc	file:	access:public
__anon7::buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon7	typeref:struct:__anon7::buf	file:	access:public
__anon7::head	bio.c	/^  struct buf head;$/;"	m	struct:__anon7	typeref:struct:__anon7::buf	file:	access:public
__anon7::lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon7	typeref:struct:__anon7::spinlock	file:	access:public
__anon9::file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon9	typeref:struct:__anon9::file	file:	access:public
__anon9::lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anon9	typeref:struct:__anon9::spinlock	file:	access:public
_start	entry.S	/^_start = V2P_WO(entry)$/;"	d
acquire	defs.h	/^void            acquire(struct spinlock*);$/;"	p	signature:(struct spinlock*)
acquire	spinlock.c	/^acquire(struct spinlock *lk)$/;"	f	signature:(struct spinlock *lk)
acquiresleep	defs.h	/^void            acquiresleep(struct sleeplock*);$/;"	p	signature:(struct sleeplock*)
acquiresleep	sleeplock.c	/^acquiresleep(struct sleeplock *lk)$/;"	f	signature:(struct sleeplock *lk)
addr	mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic	access:public
addrs	file.h	/^  uint addrs[NDIRECT+2];$/;"	m	struct:inode	access:public
addrs	file_bak.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode	access:public
addrs	fs.h	/^  uint addrs[NDIRECT+2];   \/\/ Data block addresses$/;"	m	struct:dinode	access:public
addrs	fs_bak.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode	access:public
alarm	user.h	/^int alarm(int ticks, void (*handler)());$/;"	p	signature:(int ticks, void (*handler)())
alarmhandler	proc.h	/^  void (*alarmhandler)();      \/\/ hw5 alarmhandler$/;"	m	struct:proc	access:public
alarmticks	proc.h	/^  int alarmticks;              \/\/ hw5 alarmticks$/;"	m	struct:proc	access:public
align	elf.h	/^  uint align;$/;"	m	struct:proghdr	access:public
all_thread	uthread.c	/^static thread_t all_thread[MAX_THREAD];$/;"	v	file:
allocproc	proc.c	/^allocproc(void)$/;"	f	file:	signature:(void)
allocuvm	defs.h	/^int             allocuvm(pde_t*, uint, uint);$/;"	p	signature:(pde_t*, uint, uint)
allocuvm	vm.c	/^allocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f	signature:(pde_t *pgdir, uint oldsz, uint newsz)
alltraps	trapasm.S	/^alltraps:$/;"	l
apicid	mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc	access:public
apicid	proc.h	/^  uchar apicid;                \/\/ Local APIC ID$/;"	m	struct:cpu	access:public
apicno	mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic	access:public
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:	signature:(int n, int *pfd, struct file **pf)
argint	defs.h	/^int             argint(int, int*);$/;"	p	signature:(int, int*)
argint	syscall.c	/^argint(int n, int *ip)$/;"	f	signature:(int n, int *ip)
argptest	usertests.c	/^void argptest()$/;"	f
argptr	defs.h	/^int             argptr(int, char**, int);$/;"	p	signature:(int, char**, int)
argptr	syscall.c	/^argptr(int n, char **pp, int size)$/;"	f	signature:(int n, char **pp, int size)
args	mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc	access:public
argstr	defs.h	/^int             argstr(int, char**);$/;"	p	signature:(int, char**)
argstr	syscall.c	/^argstr(int n, char **pp)$/;"	f	signature:(int n, char **pp)
argv	init.c	/^char *argv[] = { "sh", 0 };$/;"	v
argv	initcode.S	/^argv:$/;"	l
argv	sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:	access:public
atoi	ulib.c	/^atoi(const char *s)$/;"	f	signature:(const char *s)
atoi	user.h	/^int atoi(const char*);$/;"	p	signature:(const char*)
avl	mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc	access:public
backcmd	sh.c	/^backcmd(struct cmd *subcmd)$/;"	f	signature:(struct cmd *subcmd)
backcmd	sh.c	/^struct backcmd {$/;"	s	file:
backcmd::cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:	access:public
backcmd::type	sh.c	/^  int type;$/;"	m	struct:backcmd	file:	access:public
balloc	fs.c	/^balloc(uint dev)$/;"	f	file:	signature:(uint dev)
balloc	fs_bak.c	/^balloc(uint dev)$/;"	f	file:	signature:(uint dev)
balloc	mkfs.c	/^balloc(int used)$/;"	f	signature:(int used)
balloc	mkfs.c	/^void balloc(int);$/;"	p	file:	signature:(int)
base	umalloc.c	/^static Header base;$/;"	v	file:
base_15_0	mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc	access:public
base_23_16	mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc	access:public
base_31_24	mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc	access:public
bcache	bio.c	/^} bcache;$/;"	v	typeref:struct:__anon7
begin_op	defs.h	/^void            begin_op();$/;"	p	signature:()
begin_op	log.c	/^begin_op(void)$/;"	f	signature:(void)
begin_op	log_bak.c	/^begin_op(void)$/;"	f	signature:(void)
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	file:	signature:(int dev, uint b)
bfree	fs_bak.c	/^bfree(int dev, uint b)$/;"	f	file:	signature:(int dev, uint b)
bget	bio.c	/^bget(uint dev, uint blockno)$/;"	f	file:	signature:(uint dev, uint blockno)
bigargtest	usertests.c	/^bigargtest(void)$/;"	f	signature:(void)
bigdir	usertests.c	/^bigdir(void)$/;"	f	signature:(void)
bigfile	usertests.c	/^bigfile(void)$/;"	f	signature:(void)
bigwrite	usertests.c	/^bigwrite(void)$/;"	f	signature:(void)
binit	bio.c	/^binit(void)$/;"	f	signature:(void)
binit	defs.h	/^void            binit(void);$/;"	p	signature:(void)
block	log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:	access:public
block	log_bak.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:	access:public
blockno	buf.h	/^  uint blockno;$/;"	m	struct:buf	access:public
bmap	fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:	signature:(struct inode *ip, uint bn)
bmap	fs_bak.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:	signature:(struct inode *ip, uint bn)
bmapstart	fs.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock	access:public
bmapstart	fs_bak.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock	access:public
bootmain	bootmain.c	/^bootmain(void)$/;"	f	signature:(void)
bread	bio.c	/^bread(uint dev, uint blockno)$/;"	f	signature:(uint dev, uint blockno)
bread	defs.h	/^struct buf*     bread(uint, uint);$/;"	p	signature:(uint, uint)
brelse	bio.c	/^brelse(struct buf *b)$/;"	f	signature:(struct buf *b)
brelse	defs.h	/^void            brelse(struct buf*);$/;"	p	signature:(struct buf*)
bsstest	usertests.c	/^bsstest(void)$/;"	f	signature:(void)
buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon7	typeref:struct:__anon7::buf	file:	access:public
buf	buf.h	/^struct buf {$/;"	s
buf	cat.c	/^char buf[512];$/;"	v
buf	console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon3	file:	access:public
buf	grep.c	/^char buf[1024];$/;"	v
buf	usertests.c	/^char buf[8192];$/;"	v
buf	wc.c	/^char buf[512];$/;"	v
buf::blockno	buf.h	/^  uint blockno;$/;"	m	struct:buf	access:public
buf::data	buf.h	/^  uchar data[BSIZE];$/;"	m	struct:buf	access:public
buf::dev	buf.h	/^  uint dev;$/;"	m	struct:buf	access:public
buf::flags	buf.h	/^  int flags;$/;"	m	struct:buf	access:public
buf::lock	buf.h	/^  struct sleeplock lock;$/;"	m	struct:buf	typeref:struct:buf::sleeplock	access:public
buf::next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf	access:public
buf::prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf	access:public
buf::qnext	buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf	access:public
buf::refcnt	buf.h	/^  uint refcnt;$/;"	m	struct:buf	access:public
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f	signature:(struct buf *b)
bwrite	defs.h	/^void            bwrite(struct buf*);$/;"	p	signature:(struct buf*)
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	file:	signature:(int dev, int bno)
bzero	fs_bak.c	/^bzero(int dev, int bno)$/;"	f	file:	signature:(int dev, int bno)
cat	cat.c	/^cat(int fd)$/;"	f	signature:(int fd)
cgaputc	console.c	/^cgaputc(int c)$/;"	f	file:	signature:(int c)
chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc	access:public
chdir	user.h	/^int chdir(const char*);$/;"	p	signature:(const char*)
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp	access:public
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf	access:public
clearpteu	defs.h	/^void            clearpteu(pde_t *pgdir, char *uva);$/;"	p	signature:(pde_t *pgdir, char *uva)
clearpteu	vm.c	/^clearpteu(pde_t *pgdir, char *uva)$/;"	f	signature:(pde_t *pgdir, char *uva)
cli	x86.h	/^cli(void)$/;"	f	signature:(void)
close	user.h	/^int close(int);$/;"	p	signature:(int)
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:	access:public
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:	access:public
cmd	sh.c	/^struct cmd {$/;"	s	file:
cmd::type	sh.c	/^  int type;$/;"	m	struct:cmd	file:	access:public
cmos_read	lapic.c	/^cmos_read(uint reg)$/;"	f	file:	signature:(uint reg)
cmostime	defs.h	/^void            cmostime(struct rtcdate *r);$/;"	p	signature:(struct rtcdate *r)
cmostime	lapic.c	/^cmostime(struct rtcdate *r)$/;"	f	signature:(struct rtcdate *r)
commit	log.c	/^commit(void)$/;"	f	signature:(void)
commit	log.c	/^static void commit();$/;"	p	file:
commit	log_bak.c	/^commit()$/;"	f	file:
commit	log_bak.c	/^static void commit();$/;"	p	file:
committing	log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:	access:public
committing	log_bak.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:	access:public
concreate	usertests.c	/^concreate(void)$/;"	f	signature:(void)
cons	console.c	/^} cons;$/;"	v	typeref:struct:__anon2	file:
consoleinit	console.c	/^consoleinit(void)$/;"	f	signature:(void)
consoleinit	defs.h	/^void            consoleinit(void);$/;"	p	signature:(void)
consoleintr	console.c	/^consoleintr(int (*getc)(void))$/;"	f	signature:(int (*getc)(void))
consoleintr	defs.h	/^void            consoleintr(int(*)(void));$/;"	p	signature:(int(*)(void))
consoleread	console.c	/^consoleread(struct inode *ip, char *dst, int n)$/;"	f	signature:(struct inode *ip, char *dst, int n)
consolewrite	console.c	/^consolewrite(struct inode *ip, char *buf, int n)$/;"	f	signature:(struct inode *ip, char *buf, int n)
consputc	console.c	/^consputc(int c)$/;"	f	signature:(int c)
consputc	console.c	/^static void consputc(int);$/;"	p	file:	signature:(int)
context	proc.h	/^  struct context *context;     \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context	access:public
context	proc.h	/^struct context {$/;"	s
context::ebp	proc.h	/^  uint ebp;$/;"	m	struct:context	access:public
context::ebx	proc.h	/^  uint ebx;$/;"	m	struct:context	access:public
context::edi	proc.h	/^  uint edi;$/;"	m	struct:context	access:public
context::eip	proc.h	/^  uint eip;$/;"	m	struct:context	access:public
context::esi	proc.h	/^  uint esi;$/;"	m	struct:context	access:public
copyout	defs.h	/^int             copyout(pde_t*, uint, void*, uint);$/;"	p	signature:(pde_t*, uint, void*, uint)
copyout	vm.c	/^copyout(pde_t *pgdir, uint va, void *p, uint len)$/;"	f	signature:(pde_t *pgdir, uint va, void *p, uint len)
copyuvm	defs.h	/^pde_t*          copyuvm(pde_t*, uint);$/;"	p	signature:(pde_t*, uint)
copyuvm	vm.c	/^copyuvm(pde_t *pgdir, uint sz)$/;"	f	signature:(pde_t *pgdir, uint sz)
cprintf	console.c	/^cprintf(char *fmt, ...)$/;"	f	signature:(char *fmt, ...)
cprintf	defs.h	/^void            cprintf(char*, ...);$/;"	p	signature:(char*, ...)
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu	access:public
cpu::apicid	proc.h	/^  uchar apicid;                \/\/ Local APIC ID$/;"	m	struct:cpu	access:public
cpu::gdt	proc.h	/^  struct segdesc gdt[NSEGS];   \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc	access:public
cpu::intena	proc.h	/^  int intena;                  \/\/ Were interrupts enabled before pushcli?$/;"	m	struct:cpu	access:public
cpu::ncli	proc.h	/^  int ncli;                    \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu	access:public
cpu::proc	proc.h	/^  struct proc *proc;           \/\/ The process running on this cpu or null$/;"	m	struct:cpu	typeref:struct:cpu::proc	access:public
cpu::scheduler	proc.h	/^  struct context *scheduler;   \/\/ swtch() here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context	access:public
cpu::started	proc.h	/^  volatile uint started;       \/\/ Has the CPU started?$/;"	m	struct:cpu	access:public
cpu::ts	proc.h	/^  struct taskstate ts;         \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate	access:public
cpuid	defs.h	/^int             cpuid(void);$/;"	p	signature:(void)
cpuid	proc.c	/^cpuid() {$/;"	f
cpus	mp.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
cr3	mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate	access:public
create	sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:	signature:(char *path, short type, short major, short minor)
createdelete	usertests.c	/^createdelete(void)$/;"	f	signature:(void)
createtest	usertests.c	/^createtest(void)$/;"	f	signature:(void)
crt	console.c	/^static ushort *crt = (ushort*)P2V(0xb8000);  \/\/ CGA memory$/;"	v	file:
cs	mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc	access:public
cs	mmu.h	/^  ushort cs;$/;"	m	struct:taskstate	access:public
cs	x86.h	/^  ushort cs;$/;"	m	struct:trapframe	access:public
ctlmap	kbd.h	/^static uchar ctlmap[256] =$/;"	v
current_thread	uthread.c	/^thread_p  current_thread;$/;"	v
cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode	access:public
data	buf.h	/^  uchar data[BSIZE];$/;"	m	struct:buf	access:public
data	ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:	access:public
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:	access:public
date	user.h	/^int date(struct rtcdate *);$/;"	p	signature:(struct rtcdate *)
day	date.h	/^  uint day;$/;"	m	struct:rtcdate	access:public
db	mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc	access:public
deallocuvm	defs.h	/^int             deallocuvm(pde_t*, uint, uint);$/;"	p	signature:(pde_t*, uint, uint)
deallocuvm	vm.c	/^deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f	signature:(pde_t *pgdir, uint oldsz, uint newsz)
dev	buf.h	/^  uint dev;$/;"	m	struct:buf	access:public
dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode	access:public
dev	file_bak.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode	access:public
dev	log.c	/^  int dev;$/;"	m	struct:log	file:	access:public
dev	log_bak.c	/^  int dev;$/;"	m	struct:log	file:	access:public
dev	stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat	access:public
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
devsw	file.h	/^struct devsw {$/;"	s
devsw	file_bak.h	/^struct devsw {$/;"	s
devsw::read	file.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
devsw::read	file_bak.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
devsw::write	file.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
devsw::write	file_bak.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
dinode	fs.h	/^struct dinode {$/;"	s
dinode	fs_bak.h	/^struct dinode {$/;"	s
dinode::addrs	fs.h	/^  uint addrs[NDIRECT+2];   \/\/ Data block addresses$/;"	m	struct:dinode	access:public
dinode::addrs	fs_bak.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode	access:public
dinode::major	fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode	access:public
dinode::major	fs_bak.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode	access:public
dinode::minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode	access:public
dinode::minor	fs_bak.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode	access:public
dinode::nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode	access:public
dinode::nlink	fs_bak.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode	access:public
dinode::size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode	access:public
dinode::size	fs_bak.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode	access:public
dinode::type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode	access:public
dinode::type	fs_bak.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode	access:public
dirent	fs.h	/^struct dirent {$/;"	s
dirent	fs_bak.h	/^struct dirent {$/;"	s
dirent::inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent	access:public
dirent::inum	fs_bak.h	/^  ushort inum;$/;"	m	struct:dirent	access:public
dirent::name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent	access:public
dirent::name	fs_bak.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent	access:public
dirfile	usertests.c	/^dirfile(void)$/;"	f	signature:(void)
dirlink	defs.h	/^int             dirlink(struct inode*, char*, uint);$/;"	p	signature:(struct inode*, char*, uint)
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f	signature:(struct inode *dp, char *name, uint inum)
dirlink	fs_bak.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f	signature:(struct inode *dp, char *name, uint inum)
dirlookup	defs.h	/^struct inode*   dirlookup(struct inode*, char*, uint*);$/;"	p	signature:(struct inode*, char*, uint*)
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f	signature:(struct inode *dp, char *name, uint *poff)
dirlookup	fs_bak.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f	signature:(struct inode *dp, char *name, uint *poff)
dirtest	usertests.c	/^void dirtest(void)$/;"	f	signature:(void)
disksize	memide.c	/^static int disksize;$/;"	v	file:
dpl	mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc	access:public
dpl	mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc	access:public
ds	mmu.h	/^  ushort ds;$/;"	m	struct:taskstate	access:public
ds	x86.h	/^  ushort ds;$/;"	m	struct:trapframe	access:public
dup	user.h	/^int dup(int);$/;"	p	signature:(int)
e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon3	file:	access:public
eargv	sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:	access:public
eax	mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate	access:public
eax	x86.h	/^  uint eax;$/;"	m	struct:trapframe	access:public
ebp	mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate	access:public
ebp	proc.h	/^  uint ebp;$/;"	m	struct:context	access:public
ebp	x86.h	/^  uint ebp;$/;"	m	struct:trapframe	access:public
ebx	mmu.h	/^  uint ebx;$/;"	m	struct:taskstate	access:public
ebx	proc.h	/^  uint ebx;$/;"	m	struct:context	access:public
ebx	x86.h	/^  uint ebx;$/;"	m	struct:trapframe	access:public
echoargv	usertests.c	/^char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };$/;"	v
ecx	mmu.h	/^  uint ecx;$/;"	m	struct:taskstate	access:public
ecx	x86.h	/^  uint ecx;$/;"	m	struct:trapframe	access:public
edi	mmu.h	/^  uint edi;$/;"	m	struct:taskstate	access:public
edi	proc.h	/^  uint edi;$/;"	m	struct:context	access:public
edi	x86.h	/^  uint edi;$/;"	m	struct:trapframe	access:public
edx	mmu.h	/^  uint edx;$/;"	m	struct:taskstate	access:public
edx	x86.h	/^  uint edx;$/;"	m	struct:trapframe	access:public
efile	sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:	access:public
eflags	mmu.h	/^  uint eflags;$/;"	m	struct:taskstate	access:public
eflags	x86.h	/^  uint eflags;$/;"	m	struct:trapframe	access:public
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr	access:public
eip	mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate	access:public
eip	proc.h	/^  uint eip;$/;"	m	struct:context	access:public
eip	x86.h	/^  uint eip;$/;"	m	struct:trapframe	access:public
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr	access:public
elfhdr	elf.h	/^struct elfhdr {$/;"	s
elfhdr::ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr	access:public
elfhdr::elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr	access:public
elfhdr::entry	elf.h	/^  uint entry;$/;"	m	struct:elfhdr	access:public
elfhdr::flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr	access:public
elfhdr::machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr	access:public
elfhdr::magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr	access:public
elfhdr::phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr	access:public
elfhdr::phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr	access:public
elfhdr::phoff	elf.h	/^  uint phoff;$/;"	m	struct:elfhdr	access:public
elfhdr::shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr	access:public
elfhdr::shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr	access:public
elfhdr::shoff	elf.h	/^  uint shoff;$/;"	m	struct:elfhdr	access:public
elfhdr::shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr	access:public
elfhdr::type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr	access:public
elfhdr::version	elf.h	/^  uint version;$/;"	m	struct:elfhdr	access:public
end_op	defs.h	/^void            end_op();$/;"	p	signature:()
end_op	log.c	/^end_op(void)$/;"	f	signature:(void)
end_op	log_bak.c	/^end_op(void)$/;"	f	signature:(void)
entry	elf.h	/^  uint entry;$/;"	m	struct:elfhdr	access:public
entry	entry.S	/^entry:$/;"	l
entry	mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf	access:public
entrypgdir	main.c	/^pde_t entrypgdir[NPDENTRIES] = {$/;"	v
entrypgdir	main.c	/^pde_t entrypgdir[];  \/\/ For entry.S$/;"	v
err	x86.h	/^  uint err;$/;"	m	struct:trapframe	access:public
es	mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate	access:public
es	x86.h	/^  ushort es;$/;"	m	struct:trapframe	access:public
esi	mmu.h	/^  uint esi;$/;"	m	struct:taskstate	access:public
esi	proc.h	/^  uint esi;$/;"	m	struct:context	access:public
esi	x86.h	/^  uint esi;$/;"	m	struct:trapframe	access:public
esp	mmu.h	/^  uint *esp;$/;"	m	struct:taskstate	access:public
esp	x86.h	/^  uint esp;$/;"	m	struct:trapframe	access:public
esp0	mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate	access:public
esp1	mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate	access:public
esp2	mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate	access:public
exec	defs.h	/^int             exec(char*, char**);$/;"	p	signature:(char*, char**)
exec	exec.c	/^exec(char *path, char **argv)$/;"	f	signature:(char *path, char **argv)
exec	user.h	/^int exec(char*, char**);$/;"	p	signature:(char*, char**)
execcmd	sh.c	/^execcmd(void)$/;"	f	signature:(void)
execcmd	sh.c	/^struct execcmd {$/;"	s	file:
execcmd::argv	sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:	access:public
execcmd::eargv	sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:	access:public
execcmd::type	sh.c	/^  int type;$/;"	m	struct:execcmd	file:	access:public
exectest	usertests.c	/^exectest(void)$/;"	f	signature:(void)
exit	defs.h	/^void            exit(void);$/;"	p	signature:(void)
exit	initcode.S	/^exit:$/;"	l
exit	proc.c	/^exit(void)$/;"	f	signature:(void)
exit	user.h	/^int exit(void) __attribute__((noreturn));$/;"	p	signature:(void)
exitiputtest	usertests.c	/^exitiputtest(void)$/;"	f	signature:(void)
exitwait	usertests.c	/^exitwait(void)$/;"	f	signature:(void)
f	Makefile	/^	dd if=\/dev\/zero of=xv6.img count=10000$/;"	m
f	Makefile	/^	dd if=\/dev\/zero of=xv6memfs.img count=10000$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6memfs.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernel of=xv6.img seek=1 conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc$/;"	m
fd	sh.c	/^  int fd;$/;"	m	struct:redircmd	file:	access:public
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:	signature:(struct file *f)
feature	mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc	access:public
fetchint	defs.h	/^int             fetchint(uint, int*);$/;"	p	signature:(uint, int*)
fetchint	syscall.c	/^fetchint(uint addr, int *ip)$/;"	f	signature:(uint addr, int *ip)
fetchstr	defs.h	/^int             fetchstr(uint, char**);$/;"	p	signature:(uint, char**)
fetchstr	syscall.c	/^fetchstr(uint addr, char **pp)$/;"	f	signature:(uint addr, char **pp)
file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon9	typeref:struct:__anon9::file	file:	access:public
file	file.h	/^struct file {$/;"	s
file	file_bak.h	/^struct file {$/;"	s
file	sh.c	/^  char *file;$/;"	m	struct:redircmd	file:	access:public
file::FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon8
file::FD_INODE	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
file::FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon8
file::FD_NONE	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
file::FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon8
file::FD_PIPE	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
file::ip	file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode	access:public
file::ip	file_bak.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode	access:public
file::off	file.h	/^  uint off;$/;"	m	struct:file	access:public
file::off	file_bak.h	/^  uint off;$/;"	m	struct:file	access:public
file::pipe	file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe	access:public
file::pipe	file_bak.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe	access:public
file::readable	file.h	/^  char readable;$/;"	m	struct:file	access:public
file::readable	file_bak.h	/^  char readable;$/;"	m	struct:file	access:public
file::ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file	access:public
file::ref	file_bak.h	/^  int ref; \/\/ reference count$/;"	m	struct:file	access:public
file::type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon8	access:public
file::type	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon5	access:public
file::writable	file.h	/^  char writable;$/;"	m	struct:file	access:public
file::writable	file_bak.h	/^  char writable;$/;"	m	struct:file	access:public
filealloc	defs.h	/^struct file*    filealloc(void);$/;"	p	signature:(void)
filealloc	file.c	/^filealloc(void)$/;"	f	signature:(void)
fileclose	defs.h	/^void            fileclose(struct file*);$/;"	p	signature:(struct file*)
fileclose	file.c	/^fileclose(struct file *f)$/;"	f	signature:(struct file *f)
filedup	defs.h	/^struct file*    filedup(struct file*);$/;"	p	signature:(struct file*)
filedup	file.c	/^filedup(struct file *f)$/;"	f	signature:(struct file *f)
fileinit	defs.h	/^void            fileinit(void);$/;"	p	signature:(void)
fileinit	file.c	/^fileinit(void)$/;"	f	signature:(void)
fileread	defs.h	/^int             fileread(struct file*, char*, int n);$/;"	p	signature:(struct file*, char*, int n)
fileread	file.c	/^fileread(struct file *f, char *addr, int n)$/;"	f	signature:(struct file *f, char *addr, int n)
filestat	defs.h	/^int             filestat(struct file*, struct stat*);$/;"	p	signature:(struct file*, struct stat*)
filestat	file.c	/^filestat(struct file *f, struct stat *st)$/;"	f	signature:(struct file *f, struct stat *st)
filesz	elf.h	/^  uint filesz;$/;"	m	struct:proghdr	access:public
filewrite	defs.h	/^int             filewrite(struct file*, char*, int n);$/;"	p	signature:(struct file*, char*, int n)
filewrite	file.c	/^filewrite(struct file *f, char *addr, int n)$/;"	f	signature:(struct file *f, char *addr, int n)
fill_rtcdate	lapic.c	/^fill_rtcdate(struct rtcdate *r)$/;"	f	file:	signature:(struct rtcdate *r)
flags	buf.h	/^  int flags;$/;"	m	struct:buf	access:public
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr	access:public
flags	elf.h	/^  uint flags;$/;"	m	struct:proghdr	access:public
flags	mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc	access:public
flags	mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic	access:public
fmtname	ls.c	/^fmtname(char *path)$/;"	f	signature:(char *path)
fork	defs.h	/^int             fork(void);$/;"	p	signature:(void)
fork	proc.c	/^fork(void)$/;"	f	signature:(void)
fork	user.h	/^int fork(void);$/;"	p	signature:(void)
fork1	sh.c	/^fork1(void)$/;"	f	signature:(void)
fork1	sh.c	/^int fork1(void);  \/\/ Fork but panics on failure.$/;"	p	file:	signature:(void)
forkret	proc.c	/^extern void forkret(void);$/;"	p	file:	signature:(void)
forkret	proc.c	/^forkret(void)$/;"	f	signature:(void)
forktest	forktest.c	/^forktest(void)$/;"	f	signature:(void)
forktest	usertests.c	/^forktest(void)$/;"	f	signature:(void)
fourfiles	usertests.c	/^fourfiles(void)$/;"	f	signature:(void)
fourteen	usertests.c	/^fourteen(void)$/;"	f	signature:(void)
free	umalloc.c	/^free(void *ap)$/;"	f	signature:(void *ap)
free	user.h	/^void free(void*);$/;"	p	signature:(void*)
freeblock	mkfs.c	/^uint freeblock;$/;"	v
freeinode	mkfs.c	/^uint freeinode = 1;$/;"	v
freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon1	typeref:struct:__anon1::run	file:	access:public
freep	umalloc.c	/^static Header *freep;$/;"	v	file:
freerange	kalloc.c	/^freerange(void *vstart, void *vend)$/;"	f	signature:(void *vstart, void *vend)
freerange	kalloc.c	/^void freerange(void *vstart, void *vend);$/;"	p	file:	signature:(void *vstart, void *vend)
freevm	defs.h	/^void            freevm(pde_t*);$/;"	p	signature:(pde_t*)
freevm	vm.c	/^freevm(pde_t *pgdir)$/;"	f	signature:(pde_t *pgdir)
fs	mmu.h	/^  ushort fs;$/;"	m	struct:taskstate	access:public
fs	x86.h	/^  ushort fs;$/;"	m	struct:trapframe	access:public
fsfd	mkfs.c	/^int fsfd;$/;"	v
fsfull	usertests.c	/^fsfull()$/;"	f
fstat	user.h	/^int fstat(int fd, struct stat*);$/;"	p	signature:(int fd, struct stat*)
ftable	file.c	/^} ftable;$/;"	v	typeref:struct:__anon9
g	mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc	access:public
gatedesc	mmu.h	/^struct gatedesc {$/;"	s
gatedesc::args	mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc	access:public
gatedesc::cs	mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc	access:public
gatedesc::dpl	mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc	access:public
gatedesc::off_15_0	mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc	access:public
gatedesc::off_31_16	mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc	access:public
gatedesc::p	mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc	access:public
gatedesc::rsv1	mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc	access:public
gatedesc::s	mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc	access:public
gatedesc::type	mmu.h	/^  uint type : 4;        \/\/ type(STS_{IG32,TG32})$/;"	m	struct:gatedesc	access:public
gdt	bootasm.S	/^gdt:$/;"	l
gdt	entryother.S	/^gdt:$/;"	l
gdt	proc.h	/^  struct segdesc gdt[NSEGS];   \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc	access:public
gdtdesc	bootasm.S	/^gdtdesc:$/;"	l
gdtdesc	entryother.S	/^gdtdesc:$/;"	l
getcallerpcs	defs.h	/^void            getcallerpcs(void*, uint*);$/;"	p	signature:(void*, uint*)
getcallerpcs	spinlock.c	/^getcallerpcs(void *v, uint pcs[])$/;"	f	signature:(void *v, uint pcs[])
getcmd	sh.c	/^getcmd(char *buf, int nbuf)$/;"	f	signature:(char *buf, int nbuf)
getpid	user.h	/^int getpid(void);$/;"	p	signature:(void)
gets	ulib.c	/^gets(char *buf, int max)$/;"	f	signature:(char *buf, int max)
gets	user.h	/^char* gets(char*, int max);$/;"	p	signature:(char*, int max)
gettoken	sh.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f	signature:(char **ps, char *es, char **q, char **eq)
grep	grep.c	/^grep(char *pattern, int fd)$/;"	f	signature:(char *pattern, int fd)
growproc	defs.h	/^int             growproc(int);$/;"	p	signature:(int)
growproc	proc.c	/^growproc(int n)$/;"	f	signature:(int n)
gs	mmu.h	/^  ushort gs;$/;"	m	struct:taskstate	access:public
gs	x86.h	/^  ushort gs;$/;"	m	struct:trapframe	access:public
havedisk1	ide.c	/^static int havedisk1;$/;"	v	file:
head	bio.c	/^  struct buf head;$/;"	m	struct:__anon7	typeref:struct:__anon7::buf	file:	access:public
header	umalloc.c	/^union header {$/;"	u	file:
header::__anon6::ptr	umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon6	typeref:union:header::__anon6::header	file:	access:public
header::__anon6::size	umalloc.c	/^    uint size;$/;"	m	struct:header::__anon6	file:	access:public
header::s	umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon6	file:	access:public
header::x	umalloc.c	/^  Align x;$/;"	m	union:header	file:	access:public
holding	defs.h	/^int             holding(struct spinlock*);$/;"	p	signature:(struct spinlock*)
holding	spinlock.c	/^holding(struct spinlock *lock)$/;"	f	signature:(struct spinlock *lock)
holdingsleep	defs.h	/^int             holdingsleep(struct sleeplock*);$/;"	p	signature:(struct sleeplock*)
holdingsleep	sleeplock.c	/^holdingsleep(struct sleeplock *lk)$/;"	f	signature:(struct sleeplock *lk)
hour	date.h	/^  uint hour;$/;"	m	struct:rtcdate	access:public
ialloc	defs.h	/^struct inode*   ialloc(uint, short);$/;"	p	signature:(uint, short)
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f	signature:(uint dev, short type)
ialloc	fs_bak.c	/^ialloc(uint dev, short type)$/;"	f	signature:(uint dev, short type)
ialloc	mkfs.c	/^ialloc(ushort type)$/;"	f	signature:(ushort type)
ialloc	mkfs.c	/^uint ialloc(ushort type);$/;"	p	file:	signature:(ushort type)
iappend	mkfs.c	/^iappend(uint inum, void *xp, int n)$/;"	f	signature:(uint inum, void *xp, int n)
iappend	mkfs.c	/^void iappend(uint inum, void *p, int n);$/;"	p	file:	signature:(uint inum, void *p, int n)
icache	fs.c	/^} icache;$/;"	v	typeref:struct:__anon11
icache	fs_bak.c	/^} icache;$/;"	v	typeref:struct:__anon10
ideinit	defs.h	/^void            ideinit(void);$/;"	p	signature:(void)
ideinit	ide.c	/^ideinit(void)$/;"	f	signature:(void)
ideinit	memide.c	/^ideinit(void)$/;"	f	signature:(void)
ideintr	defs.h	/^void            ideintr(void);$/;"	p	signature:(void)
ideintr	ide.c	/^ideintr(void)$/;"	f	signature:(void)
ideintr	memide.c	/^ideintr(void)$/;"	f	signature:(void)
idelock	ide.c	/^static struct spinlock idelock;$/;"	v	typeref:struct:spinlock	file:
idequeue	ide.c	/^static struct buf *idequeue;$/;"	v	typeref:struct:buf	file:
iderw	defs.h	/^void            iderw(struct buf*);$/;"	p	signature:(struct buf*)
iderw	ide.c	/^iderw(struct buf *b)$/;"	f	signature:(struct buf *b)
iderw	memide.c	/^iderw(struct buf *b)$/;"	f	signature:(struct buf *b)
idestart	ide.c	/^idestart(struct buf *b)$/;"	f	file:	signature:(struct buf *b)
idestart	ide.c	/^static void idestart(struct buf*);$/;"	p	file:	signature:(struct buf*)
idewait	ide.c	/^idewait(int checkerr)$/;"	f	file:	signature:(int checkerr)
idt	trap.c	/^struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc
idtinit	defs.h	/^void            idtinit(void);$/;"	p	signature:(void)
idtinit	trap.c	/^idtinit(void)$/;"	f	signature:(void)
idup	defs.h	/^struct inode*   idup(struct inode*);$/;"	p	signature:(struct inode*)
idup	fs.c	/^idup(struct inode *ip)$/;"	f	signature:(struct inode *ip)
idup	fs_bak.c	/^idup(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	file:	signature:(uint dev, uint inum)
iget	fs.c	/^static struct inode* iget(uint dev, uint inum);$/;"	p	file:	signature:(uint dev, uint inum)
iget	fs_bak.c	/^iget(uint dev, uint inum)$/;"	f	file:	signature:(uint dev, uint inum)
iget	fs_bak.c	/^static struct inode* iget(uint dev, uint inum);$/;"	p	file:	signature:(uint dev, uint inum)
iinit	defs.h	/^void            iinit(int dev);$/;"	p	signature:(int dev)
iinit	fs.c	/^iinit(int dev)$/;"	f	signature:(int dev)
iinit	fs_bak.c	/^iinit(int dev)$/;"	f	signature:(int dev)
ilock	defs.h	/^void            ilock(struct inode*);$/;"	p	signature:(struct inode*)
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f	signature:(struct inode *ip)
ilock	fs_bak.c	/^ilock(struct inode *ip)$/;"	f	signature:(struct inode *ip)
imcrp	mp.h	/^  uchar imcrp;$/;"	m	struct:mp	access:public
inb	x86.h	/^inb(ushort port)$/;"	f	signature:(ushort port)
init	initcode.S	/^init:$/;"	l
initlock	defs.h	/^void            initlock(struct spinlock*, char*);$/;"	p	signature:(struct spinlock*, char*)
initlock	spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f	signature:(struct spinlock *lk, char *name)
initlog	defs.h	/^void            initlog(int dev);$/;"	p	signature:(int dev)
initlog	log.c	/^initlog(int dev)$/;"	f	signature:(int dev)
initlog	log_bak.c	/^initlog(int dev)$/;"	f	signature:(int dev)
initproc	proc.c	/^static struct proc *initproc;$/;"	v	typeref:struct:proc	file:
initsleeplock	defs.h	/^void            initsleeplock(struct sleeplock*, char*);$/;"	p	signature:(struct sleeplock*, char*)
initsleeplock	sleeplock.c	/^initsleeplock(struct sleeplock *lk, char *name)$/;"	f	signature:(struct sleeplock *lk, char *name)
inituvm	defs.h	/^void            inituvm(pde_t*, char*, uint);$/;"	p	signature:(pde_t*, char*, uint)
inituvm	vm.c	/^inituvm(pde_t *pgdir, char *init, uint sz)$/;"	f	signature:(pde_t *pgdir, char *init, uint sz)
ino	stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat	access:public
inode	file.h	/^struct inode {$/;"	s
inode	file_bak.h	/^struct inode {$/;"	s
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon11	typeref:struct:__anon11::inode	file:	access:public
inode	fs_bak.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon10	typeref:struct:__anon10::inode	file:	access:public
inode::addrs	file.h	/^  uint addrs[NDIRECT+2];$/;"	m	struct:inode	access:public
inode::addrs	file_bak.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode	access:public
inode::dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode	access:public
inode::dev	file_bak.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode	access:public
inode::inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode	access:public
inode::inum	file_bak.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode	access:public
inode::lock	file.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock	access:public
inode::lock	file_bak.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock	access:public
inode::major	file.h	/^  short major;$/;"	m	struct:inode	access:public
inode::major	file_bak.h	/^  short major;$/;"	m	struct:inode	access:public
inode::minor	file.h	/^  short minor;$/;"	m	struct:inode	access:public
inode::minor	file_bak.h	/^  short minor;$/;"	m	struct:inode	access:public
inode::nlink	file.h	/^  short nlink;$/;"	m	struct:inode	access:public
inode::nlink	file_bak.h	/^  short nlink;$/;"	m	struct:inode	access:public
inode::ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode	access:public
inode::ref	file_bak.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode	access:public
inode::size	file.h	/^  uint size;$/;"	m	struct:inode	access:public
inode::size	file_bak.h	/^  uint size;$/;"	m	struct:inode	access:public
inode::type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode	access:public
inode::type	file_bak.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode	access:public
inode::valid	file.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode	access:public
inode::valid	file_bak.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode	access:public
inodestart	fs.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock	access:public
inodestart	fs_bak.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock	access:public
input	console.c	/^} input;$/;"	v	typeref:struct:__anon3
insl	x86.h	/^insl(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
install_trans	log.c	/^install_trans(void)$/;"	f	file:	signature:(void)
install_trans	log_bak.c	/^install_trans(void)$/;"	f	file:	signature:(void)
intena	proc.h	/^  int intena;                  \/\/ Were interrupts enabled before pushcli?$/;"	m	struct:cpu	access:public
inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode	access:public
inum	file_bak.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode	access:public
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent	access:public
inum	fs_bak.h	/^  ushort inum;$/;"	m	struct:dirent	access:public
ioapic	ioapic.c	/^struct ioapic {$/;"	s	file:
ioapic	ioapic.c	/^volatile struct ioapic *ioapic;$/;"	v	typeref:struct:ioapic
ioapic::data	ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:	access:public
ioapic::pad	ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:	access:public
ioapic::reg	ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:	access:public
ioapicenable	defs.h	/^void            ioapicenable(int irq, int cpu);$/;"	p	signature:(int irq, int cpu)
ioapicenable	ioapic.c	/^ioapicenable(int irq, int cpunum)$/;"	f	signature:(int irq, int cpunum)
ioapicid	mp.c	/^uchar ioapicid;$/;"	v
ioapicinit	defs.h	/^void            ioapicinit(void);$/;"	p	signature:(void)
ioapicinit	ioapic.c	/^ioapicinit(void)$/;"	f	signature:(void)
ioapicread	ioapic.c	/^ioapicread(int reg)$/;"	f	file:	signature:(int reg)
ioapicwrite	ioapic.c	/^ioapicwrite(int reg, uint data)$/;"	f	file:	signature:(int reg, uint data)
iomb	mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate	access:public
ip	file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode	access:public
ip	file_bak.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode	access:public
iput	defs.h	/^void            iput(struct inode*);$/;"	p	signature:(struct inode*)
iput	fs.c	/^iput(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iput	fs_bak.c	/^iput(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iputtest	usertests.c	/^iputtest(void)$/;"	f	signature:(void)
iref	usertests.c	/^iref(void)$/;"	f	signature:(void)
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:	signature:(struct inode *dp)
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f	file:	signature:(struct inode *ip)
itrunc	fs.c	/^static void itrunc(struct inode*);$/;"	p	file:	signature:(struct inode*)
itrunc	fs_bak.c	/^itrunc(struct inode *ip)$/;"	f	file:	signature:(struct inode *ip)
itrunc	fs_bak.c	/^static void itrunc(struct inode*);$/;"	p	file:	signature:(struct inode*)
iunlock	defs.h	/^void            iunlock(struct inode*);$/;"	p	signature:(struct inode*)
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iunlock	fs_bak.c	/^iunlock(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iunlockput	defs.h	/^void            iunlockput(struct inode*);$/;"	p	signature:(struct inode*)
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iunlockput	fs_bak.c	/^iunlockput(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iupdate	defs.h	/^void            iupdate(struct inode*);$/;"	p	signature:(struct inode*)
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f	signature:(struct inode *ip)
iupdate	fs_bak.c	/^iupdate(struct inode *ip)$/;"	f	signature:(struct inode *ip)
kalloc	defs.h	/^char*           kalloc(void);$/;"	p	signature:(void)
kalloc	kalloc.c	/^kalloc(void)$/;"	f	signature:(void)
kbdgetc	kbd.c	/^kbdgetc(void)$/;"	f	signature:(void)
kbdintr	defs.h	/^void            kbdintr(void);$/;"	p	signature:(void)
kbdintr	kbd.c	/^kbdintr(void)$/;"	f	signature:(void)
kfree	defs.h	/^void            kfree(char*);$/;"	p	signature:(char*)
kfree	kalloc.c	/^kfree(char *v)$/;"	f	signature:(char *v)
kill	defs.h	/^int             kill(int);$/;"	p	signature:(int)
kill	proc.c	/^kill(int pid)$/;"	f	signature:(int pid)
kill	user.h	/^int kill(int);$/;"	p	signature:(int)
killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc	access:public
kinit1	defs.h	/^void            kinit1(void*, void*);$/;"	p	signature:(void*, void*)
kinit1	kalloc.c	/^kinit1(void *vstart, void *vend)$/;"	f	signature:(void *vstart, void *vend)
kinit2	defs.h	/^void            kinit2(void*, void*);$/;"	p	signature:(void*, void*)
kinit2	kalloc.c	/^kinit2(void *vstart, void *vend)$/;"	f	signature:(void *vstart, void *vend)
kmap	vm.c	/^static struct kmap {$/;"	s	file:
kmap	vm.c	/^} kmap[] = {$/;"	v	typeref:struct:kmap	file:
kmap::perm	vm.c	/^  int perm;$/;"	m	struct:kmap	file:	access:public
kmap::phys_end	vm.c	/^  uint phys_end;$/;"	m	struct:kmap	file:	access:public
kmap::phys_start	vm.c	/^  uint phys_start;$/;"	m	struct:kmap	file:	access:public
kmap::virt	vm.c	/^  void *virt;$/;"	m	struct:kmap	file:	access:public
kmem	kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon1
kpgdir	vm.c	/^pde_t *kpgdir;  \/\/ for use in scheduler()$/;"	v
kstack	proc.h	/^  char *kstack;                \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc	access:public
kvmalloc	defs.h	/^void            kvmalloc(void);$/;"	p	signature:(void)
kvmalloc	vm.c	/^kvmalloc(void)$/;"	f	signature:(void)
lapic	lapic.c	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	v
lapicaddr	mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf	access:public
lapiceoi	defs.h	/^void            lapiceoi(void);$/;"	p	signature:(void)
lapiceoi	lapic.c	/^lapiceoi(void)$/;"	f	signature:(void)
lapicid	defs.h	/^int             lapicid(void);$/;"	p	signature:(void)
lapicid	lapic.c	/^lapicid(void)$/;"	f	signature:(void)
lapicinit	defs.h	/^void            lapicinit(void);$/;"	p	signature:(void)
lapicinit	lapic.c	/^lapicinit(void)$/;"	f	signature:(void)
lapicstartap	defs.h	/^void            lapicstartap(uchar, uint);$/;"	p	signature:(uchar, uint)
lapicstartap	lapic.c	/^lapicstartap(uchar apicid, uint addr)$/;"	f	signature:(uchar apicid, uint addr)
lapicw	lapic.c	/^lapicw(int index, int value)$/;"	f	file:	signature:(int index, int value)
lcr3	x86.h	/^lcr3(uint val)$/;"	f	signature:(uint val)
ldt	mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate	access:public
left	sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:	access:public
left	sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:	access:public
length	mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp	access:public
length	mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf	access:public
lgdt	x86.h	/^lgdt(struct segdesc *p, int size)$/;"	f	signature:(struct segdesc *p, int size)
lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:	access:public
lh	log_bak.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:	access:public
lidt	x86.h	/^lidt(struct gatedesc *p, int size)$/;"	f	signature:(struct gatedesc *p, int size)
lim_15_0	mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc	access:public
lim_19_16	mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc	access:public
link	mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate	access:public
link	user.h	/^int link(const char*, const char*);$/;"	p	signature:(const char*, const char*)
linktest	usertests.c	/^linktest(void)$/;"	f	signature:(void)
linkunlink	usertests.c	/^linkunlink()$/;"	f
listcmd	sh.c	/^listcmd(struct cmd *left, struct cmd *right)$/;"	f	signature:(struct cmd *left, struct cmd *right)
listcmd	sh.c	/^struct listcmd {$/;"	s	file:
listcmd::left	sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:	access:public
listcmd::right	sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:	access:public
listcmd::type	sh.c	/^  int type;$/;"	m	struct:listcmd	file:	access:public
lk	sleeplock.h	/^  struct spinlock lk; \/\/ spinlock protecting this sleep lock$/;"	m	struct:sleeplock	typeref:struct:sleeplock::spinlock	access:public
loadgs	x86.h	/^loadgs(ushort v)$/;"	f	signature:(ushort v)
loaduvm	defs.h	/^int             loaduvm(pde_t*, char*, struct inode*, uint, uint);$/;"	p	signature:(pde_t*, char*, struct inode*, uint, uint)
loaduvm	vm.c	/^loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)$/;"	f	signature:(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon7	typeref:struct:__anon7::spinlock	file:	access:public
lock	buf.h	/^  struct sleeplock lock;$/;"	m	struct:buf	typeref:struct:buf::sleeplock	access:public
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:	access:public
lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anon9	typeref:struct:__anon9::spinlock	file:	access:public
lock	file.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock	access:public
lock	file_bak.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock	access:public
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon11	typeref:struct:__anon11::spinlock	file:	access:public
lock	fs_bak.c	/^  struct spinlock lock;$/;"	m	struct:__anon10	typeref:struct:__anon10::spinlock	file:	access:public
lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:	access:public
lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:	access:public
lock	log_bak.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:	access:public
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:	access:public
lock	proc.c	/^  struct spinlock lock;$/;"	m	struct:__anon4	typeref:struct:__anon4::spinlock	file:	access:public
locked	sleeplock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:sleeplock	access:public
locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock	access:public
locking	console.c	/^  int locking;$/;"	m	struct:__anon2	file:	access:public
log	log.c	/^struct log log;$/;"	v	typeref:struct:log
log	log.c	/^struct log {$/;"	s	file:
log	log_bak.c	/^struct log log;$/;"	v	typeref:struct:log
log	log_bak.c	/^struct log {$/;"	s	file:
log::committing	log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:	access:public
log::committing	log_bak.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:	access:public
log::dev	log.c	/^  int dev;$/;"	m	struct:log	file:	access:public
log::dev	log_bak.c	/^  int dev;$/;"	m	struct:log	file:	access:public
log::lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:	access:public
log::lh	log_bak.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:	access:public
log::lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:	access:public
log::lock	log_bak.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:	access:public
log::outstanding	log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:	access:public
log::outstanding	log_bak.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:	access:public
log::size	log.c	/^  int size;$/;"	m	struct:log	file:	access:public
log::size	log_bak.c	/^  int size;$/;"	m	struct:log	file:	access:public
log::start	log.c	/^  int start;$/;"	m	struct:log	file:	access:public
log::start	log_bak.c	/^  int start;$/;"	m	struct:log	file:	access:public
log_write	defs.h	/^void            log_write(struct buf*);$/;"	p	signature:(struct buf*)
log_write	log.c	/^log_write(struct buf *b)$/;"	f	signature:(struct buf *b)
log_write	log_bak.c	/^log_write(struct buf *b)$/;"	f	signature:(struct buf *b)
logheader	log.c	/^struct logheader {$/;"	s	file:
logheader	log_bak.c	/^struct logheader {$/;"	s	file:
logheader::block	log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:	access:public
logheader::block	log_bak.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:	access:public
logheader::n	log.c	/^  int n;$/;"	m	struct:logheader	file:	access:public
logheader::n	log_bak.c	/^  int n;$/;"	m	struct:logheader	file:	access:public
logstart	fs.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock	access:public
logstart	fs_bak.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock	access:public
ls	ls.c	/^ls(char *path)$/;"	f	signature:(char *path)
ltr	x86.h	/^ltr(ushort sel)$/;"	f	signature:(ushort sel)
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr	access:public
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr	access:public
main	alarmtest.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	big.c	/^main()$/;"	f
main	cat.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	date.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	echo.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	forktest.c	/^main(void)$/;"	f	signature:(void)
main	grep.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	init.c	/^main(void)$/;"	f	signature:(void)
main	kill.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	ln.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	ls.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	main.c	/^main(void)$/;"	f	signature:(void)
main	mkdir.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	mkfs.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	rm.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	sh.c	/^main(void)$/;"	f	signature:(void)
main	stressfs.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	usertests.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	uthread.c	/^main(int argc, char *argv[]) $/;"	f	signature:(int argc, char *argv[])
main	wc.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	zombie.c	/^main(void)$/;"	f	signature:(void)
major	file.h	/^  short major;$/;"	m	struct:inode	access:public
major	file_bak.h	/^  short major;$/;"	m	struct:inode	access:public
major	fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode	access:public
major	fs_bak.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode	access:public
malloc	umalloc.c	/^malloc(uint nbytes)$/;"	f	signature:(uint nbytes)
malloc	user.h	/^void* malloc(uint);$/;"	p	signature:(uint)
mappages	trap.c	/^int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm); $/;"	p	file:	signature:(pde_t *pgdir, void *va, uint size, uint pa, int perm)
mappages	vm.c	/^mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)$/;"	f	signature:(pde_t *pgdir, void *va, uint size, uint pa, int perm)
match	grep.c	/^int match(char*, char*);$/;"	p	file:	signature:(char*, char*)
match	grep.c	/^match(char *re, char *text)$/;"	f	signature:(char *re, char *text)
matchhere	grep.c	/^int matchhere(char *re, char *text)$/;"	f	signature:(char *re, char *text)
matchhere	grep.c	/^int matchhere(char*, char*);$/;"	p	file:	signature:(char*, char*)
matchstar	grep.c	/^int matchstar(int c, char *re, char *text)$/;"	f	signature:(int c, char *re, char *text)
matchstar	grep.c	/^int matchstar(int, char*, char*);$/;"	p	file:	signature:(int, char*, char*)
mem	usertests.c	/^mem(void)$/;"	f	signature:(void)
memcmp	defs.h	/^int             memcmp(const void*, const void*, uint);$/;"	p	signature:(const void*, const void*, uint)
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f	signature:(const void *v1, const void *v2, uint n)
memcpy	string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f	signature:(void *dst, const void *src, uint n)
memdisk	memide.c	/^static uchar *memdisk;$/;"	v	file:
memmove	defs.h	/^void*           memmove(void*, const void*, uint);$/;"	p	signature:(void*, const void*, uint)
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f	signature:(void *dst, const void *src, uint n)
memmove	ulib.c	/^memmove(void *vdst, const void *vsrc, int n)$/;"	f	signature:(void *vdst, const void *vsrc, int n)
memmove	user.h	/^void *memmove(void*, const void*, int);$/;"	p	signature:(void*, const void*, int)
memset	defs.h	/^void*           memset(void*, int, uint);$/;"	p	signature:(void*, int, uint)
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f	signature:(void *dst, int c, uint n)
memset	ulib.c	/^memset(void *dst, int c, uint n)$/;"	f	signature:(void *dst, int c, uint n)
memset	user.h	/^void* memset(void*, int, uint);$/;"	p	signature:(void*, int, uint)
memsz	elf.h	/^  uint memsz;$/;"	m	struct:proghdr	access:public
microdelay	defs.h	/^void            microdelay(int);$/;"	p	signature:(int)
microdelay	lapic.c	/^microdelay(int us)$/;"	f	signature:(int us)
min	fs.c	24;"	d	file:
min	fs_bak.c	24;"	d	file:
min	mkfs.c	253;"	d	file:
minor	file.h	/^  short minor;$/;"	m	struct:inode	access:public
minor	file_bak.h	/^  short minor;$/;"	m	struct:inode	access:public
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode	access:public
minor	fs_bak.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode	access:public
minute	date.h	/^  uint minute;$/;"	m	struct:rtcdate	access:public
mkdir	user.h	/^int mkdir(const char*);$/;"	p	signature:(const char*)
mknod	user.h	/^int mknod(const char*, short, short);$/;"	p	signature:(const char*, short, short)
mode	sh.c	/^  int mode;$/;"	m	struct:redircmd	file:	access:public
month	date.h	/^  uint month;$/;"	m	struct:rtcdate	access:public
morecore	umalloc.c	/^morecore(uint nu)$/;"	f	file:	signature:(uint nu)
mp	mp.h	/^struct mp {             \/\/ floating pointer$/;"	s
mp::checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp	access:public
mp::imcrp	mp.h	/^  uchar imcrp;$/;"	m	struct:mp	access:public
mp::length	mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp	access:public
mp::physaddr	mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp	access:public
mp::reserved	mp.h	/^  uchar reserved[3];$/;"	m	struct:mp	access:public
mp::signature	mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp	access:public
mp::specrev	mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp	access:public
mp::type	mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp	access:public
mpconf	mp.h	/^struct mpconf {         \/\/ configuration table header$/;"	s
mpconf::checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf	access:public
mpconf::entry	mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf	access:public
mpconf::lapicaddr	mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf	access:public
mpconf::length	mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf	access:public
mpconf::oemlength	mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf	access:public
mpconf::oemtable	mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf	access:public
mpconf::product	mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf	access:public
mpconf::reserved	mp.h	/^  uchar reserved;$/;"	m	struct:mpconf	access:public
mpconf::signature	mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf	access:public
mpconf::version	mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf	access:public
mpconf::xchecksum	mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf	access:public
mpconf::xlength	mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf	access:public
mpconfig	mp.c	/^mpconfig(struct mp **pmp)$/;"	f	file:	signature:(struct mp **pmp)
mpenter	main.c	/^mpenter(void)$/;"	f	file:	signature:(void)
mpinit	defs.h	/^void            mpinit(void);$/;"	p	signature:(void)
mpinit	mp.c	/^mpinit(void)$/;"	f	signature:(void)
mpioapic	mp.h	/^struct mpioapic {       \/\/ I\/O APIC table entry$/;"	s
mpioapic::addr	mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic	access:public
mpioapic::apicno	mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic	access:public
mpioapic::flags	mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic	access:public
mpioapic::type	mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic	access:public
mpioapic::version	mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic	access:public
mpmain	main.c	/^mpmain(void)$/;"	f	file:	signature:(void)
mpmain	main.c	/^static void mpmain(void)  __attribute__((noreturn));$/;"	p	file:	signature:(void)
mpproc	mp.h	/^struct mpproc {         \/\/ processor table entry$/;"	s
mpproc::apicid	mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc	access:public
mpproc::feature	mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc	access:public
mpproc::flags	mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc	access:public
mpproc::reserved	mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc	access:public
mpproc::signature	mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc	access:public
mpproc::type	mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc	access:public
mpproc::version	mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc	access:public
mpsearch	mp.c	/^mpsearch(void)$/;"	f	file:	signature:(void)
mpsearch1	mp.c	/^mpsearch1(uint a, int len)$/;"	f	file:	signature:(uint a, int len)
multiboot_header	entry.S	/^multiboot_header:$/;"	l
mutex_p	uthread.c	/^typedef struct mutex mutex_t, *mutex_p;$/;"	t	typeref:struct:	file:
mutex_t	uthread.c	/^typedef struct mutex mutex_t, *mutex_p;$/;"	t	typeref:struct:mutex	file:
mycpu	defs.h	/^struct cpu*     mycpu(void);$/;"	p	signature:(void)
mycpu	proc.c	/^mycpu(void)$/;"	f	signature:(void)
myproc	defs.h	/^struct proc*    myproc();$/;"	p	signature:()
myproc	proc.c	/^myproc(void) {$/;"	f	signature:(void)
mythread	uthread.c	/^mythread(void)$/;"	f	file:	signature:(void)
n	log.c	/^  int n;$/;"	m	struct:logheader	file:	access:public
n	log_bak.c	/^  int n;$/;"	m	struct:logheader	file:	access:public
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent	access:public
name	fs_bak.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent	access:public
name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc	access:public
name	sleeplock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:sleeplock	access:public
name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock	access:public
name	usertests.c	/^char name[3];$/;"	v
name	usys.S	/^  name: \\$/;"	l
namecmp	defs.h	/^int             namecmp(const char*, const char*);$/;"	p	signature:(const char*, const char*)
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f	signature:(const char *s, const char *t)
namecmp	fs_bak.c	/^namecmp(const char *s, const char *t)$/;"	f	signature:(const char *s, const char *t)
namei	defs.h	/^struct inode*   namei(char*);$/;"	p	signature:(char*)
namei	fs.c	/^namei(char *path)$/;"	f	signature:(char *path)
namei	fs_bak.c	/^namei(char *path)$/;"	f	signature:(char *path)
nameiparent	defs.h	/^struct inode*   nameiparent(char*, char*);$/;"	p	signature:(char*, char*)
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f	signature:(char *path, char *name)
nameiparent	fs_bak.c	/^nameiparent(char *path, char *name)$/;"	f	signature:(char *path, char *name)
namex	fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:	signature:(char *path, int nameiparent, char *name)
namex	fs_bak.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:	signature:(char *path, int nameiparent, char *name)
nbitmap	mkfs.c	/^int nbitmap = FSSIZE\/(BSIZE*8) + 1;$/;"	v
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock	access:public
nblocks	fs_bak.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock	access:public
nblocks	mkfs.c	/^int nblocks;  \/\/ Number of data blocks$/;"	v
ncli	proc.h	/^  int ncli;                    \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu	access:public
ncpu	mp.c	/^int ncpu;$/;"	v
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf	access:public
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:	access:public
next_thread	uthread.c	/^thread_p  next_thread;$/;"	v
nextpid	proc.c	/^int nextpid = 1;$/;"	v
ninodeblocks	mkfs.c	/^int ninodeblocks = NINODES \/ IPB + 1;$/;"	v
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock	access:public
ninodes	fs_bak.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock	access:public
nlink	file.h	/^  short nlink;$/;"	m	struct:inode	access:public
nlink	file_bak.h	/^  short nlink;$/;"	m	struct:inode	access:public
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode	access:public
nlink	fs_bak.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode	access:public
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat	access:public
nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock	access:public
nlog	fs_bak.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock	access:public
nlog	mkfs.c	/^int nlog = LOGSIZE;$/;"	v
nmeta	mkfs.c	/^int nmeta;    \/\/ Number of meta blocks (boot, sb, nlog, inode, bitmap)$/;"	v
normalmap	kbd.h	/^static uchar normalmap[256] =$/;"	v
nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:	access:public
nulterminate	sh.c	/^nulterminate(struct cmd *cmd)$/;"	f	signature:(struct cmd *cmd)
nulterminate	sh.c	/^struct cmd *nulterminate(struct cmd*);$/;"	p	file:	signature:(struct cmd*)
nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:	access:public
oemlength	mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf	access:public
oemtable	mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf	access:public
oesp	x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe	access:public
off	elf.h	/^  uint off;$/;"	m	struct:proghdr	access:public
off	file.h	/^  uint off;$/;"	m	struct:file	access:public
off	file_bak.h	/^  uint off;$/;"	m	struct:file	access:public
off_15_0	mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc	access:public
off_31_16	mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc	access:public
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file	access:public
open	user.h	/^int open(const char*, int);$/;"	p	signature:(const char*, int)
openiputtest	usertests.c	/^openiputtest(void)$/;"	f	signature:(void)
opentest	usertests.c	/^opentest(void)$/;"	f	signature:(void)
outb	x86.h	/^outb(ushort port, uchar data)$/;"	f	signature:(ushort port, uchar data)
outsl	x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outstanding	log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:	access:public
outstanding	log_bak.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:	access:public
outw	x86.h	/^outw(ushort port, ushort data)$/;"	f	signature:(ushort port, ushort data)
p	mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc	access:public
p	mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc	access:public
pad	ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:	access:public
pad	runoff	/^pad()$/;"	f
padding1	mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate	access:public
padding1	x86.h	/^  ushort padding1;$/;"	m	struct:trapframe	access:public
padding10	mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate	access:public
padding2	mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate	access:public
padding2	x86.h	/^  ushort padding2;$/;"	m	struct:trapframe	access:public
padding3	mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate	access:public
padding3	x86.h	/^  ushort padding3;$/;"	m	struct:trapframe	access:public
padding4	mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate	access:public
padding4	x86.h	/^  ushort padding4;$/;"	m	struct:trapframe	access:public
padding5	mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate	access:public
padding5	x86.h	/^  ushort padding5;$/;"	m	struct:trapframe	access:public
padding6	mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate	access:public
padding6	x86.h	/^  ushort padding6;$/;"	m	struct:trapframe	access:public
padding7	mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate	access:public
padding8	mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate	access:public
padding9	mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate	access:public
paddr	elf.h	/^  uint paddr;$/;"	m	struct:proghdr	access:public
panic	console.c	/^panic(char *s)$/;"	f	signature:(char *s)
panic	defs.h	/^void            panic(char*) __attribute__((noreturn));$/;"	p	signature:(char*)
panic	sh.c	/^panic(char *s)$/;"	f	signature:(char *s)
panic	sh.c	/^void panic(char*);$/;"	p	file:	signature:(char*)
panicked	console.c	/^static int panicked = 0;$/;"	v	file:
parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc	access:public
parseblock	sh.c	/^parseblock(char **ps, char *es)$/;"	f	signature:(char **ps, char *es)
parsecmd	sh.c	/^parsecmd(char *s)$/;"	f	signature:(char *s)
parsecmd	sh.c	/^struct cmd *parsecmd(char*);$/;"	p	file:	signature:(char*)
parseexec	sh.c	/^parseexec(char **ps, char *es)$/;"	f	signature:(char **ps, char *es)
parseexec	sh.c	/^struct cmd *parseexec(char**, char*);$/;"	p	file:	signature:(char**, char*)
parseline	sh.c	/^parseline(char **ps, char *es)$/;"	f	signature:(char **ps, char *es)
parseline	sh.c	/^struct cmd *parseline(char**, char*);$/;"	p	file:	signature:(char**, char*)
parsepipe	sh.c	/^parsepipe(char **ps, char *es)$/;"	f	signature:(char **ps, char *es)
parsepipe	sh.c	/^struct cmd *parsepipe(char**, char*);$/;"	p	file:	signature:(char**, char*)
parseredirs	sh.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f	signature:(struct cmd *cmd, char **ps, char *es)
pcs	spinlock.h	/^  uint pcs[10];      \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock	access:public
pde_t	types.h	/^typedef uint pde_t;$/;"	t
peek	sh.c	/^peek(char **ps, char *es, char *toks)$/;"	f	signature:(char **ps, char *es, char *toks)
periodic	alarmtest.c	/^periodic()$/;"	f
periodic	alarmtest.c	/^void periodic();$/;"	p	file:
perm	vm.c	/^  int perm;$/;"	m	struct:kmap	file:	access:public
pgdir	proc.h	/^  pde_t* pgdir;                \/\/ Page table$/;"	m	struct:proc	access:public
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr	access:public
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr	access:public
phoff	elf.h	/^  uint phoff;$/;"	m	struct:elfhdr	access:public
phys_end	vm.c	/^  uint phys_end;$/;"	m	struct:kmap	file:	access:public
phys_start	vm.c	/^  uint phys_start;$/;"	m	struct:kmap	file:	access:public
physaddr	mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp	access:public
picenable	defs.h	/^void            picenable(int);$/;"	p	signature:(int)
picinit	defs.h	/^void            picinit(void);$/;"	p	signature:(void)
picinit	picirq.c	/^picinit(void)$/;"	f	signature:(void)
pid	proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc	access:public
pid	sleeplock.h	/^  int pid;           \/\/ Process holding lock$/;"	m	struct:sleeplock	access:public
pinit	defs.h	/^void            pinit(void);$/;"	p	signature:(void)
pinit	proc.c	/^pinit(void)$/;"	f	signature:(void)
pipe	file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe	access:public
pipe	file_bak.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe	access:public
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipe	user.h	/^int pipe(int*);$/;"	p	signature:(int*)
pipe1	usertests.c	/^pipe1(void)$/;"	f	signature:(void)
pipe::data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:	access:public
pipe::lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:	access:public
pipe::nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:	access:public
pipe::nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:	access:public
pipe::readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:	access:public
pipe::writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:	access:public
pipealloc	defs.h	/^int             pipealloc(struct file**, struct file**);$/;"	p	signature:(struct file**, struct file**)
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f	signature:(struct file **f0, struct file **f1)
pipeclose	defs.h	/^void            pipeclose(struct pipe*, int);$/;"	p	signature:(struct pipe*, int)
pipeclose	pipe.c	/^pipeclose(struct pipe *p, int writable)$/;"	f	signature:(struct pipe *p, int writable)
pipecmd	sh.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f	signature:(struct cmd *left, struct cmd *right)
pipecmd	sh.c	/^struct pipecmd {$/;"	s	file:
pipecmd::left	sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:	access:public
pipecmd::right	sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:	access:public
pipecmd::type	sh.c	/^  int type;$/;"	m	struct:pipecmd	file:	access:public
piperead	defs.h	/^int             piperead(struct pipe*, char*, int);$/;"	p	signature:(struct pipe*, char*, int)
piperead	pipe.c	/^piperead(struct pipe *p, char *addr, int n)$/;"	f	signature:(struct pipe *p, char *addr, int n)
pipewrite	defs.h	/^int             pipewrite(struct pipe*, char*, int);$/;"	p	signature:(struct pipe*, char*, int)
pipewrite	pipe.c	/^pipewrite(struct pipe *p, char *addr, int n)$/;"	f	signature:(struct pipe *p, char *addr, int n)
popcli	defs.h	/^void            popcli(void);$/;"	p	signature:(void)
popcli	spinlock.c	/^popcli(void)$/;"	f	signature:(void)
preempt	usertests.c	/^preempt(void)$/;"	f	signature:(void)
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf	access:public
printf	forktest.c	/^printf(int fd, const char *s, ...)$/;"	f	signature:(int fd, const char *s, ...)
printf	printf.c	/^printf(int fd, const char *fmt, ...)$/;"	f	signature:(int fd, const char *fmt, ...)
printf	user.h	/^void printf(int, const char*, ...);$/;"	p	signature:(int, const char*, ...)
printint	console.c	/^printint(int xx, int base, int sign)$/;"	f	file:	signature:(int xx, int base, int sign)
printint	printf.c	/^printint(int fd, int xx, int base, int sgn)$/;"	f	file:	signature:(int fd, int xx, int base, int sgn)
proc	proc.c	/^  struct proc proc[NPROC];$/;"	m	struct:__anon4	typeref:struct:__anon4::proc	file:	access:public
proc	proc.h	/^  struct proc *proc;           \/\/ The process running on this cpu or null$/;"	m	struct:cpu	typeref:struct:cpu::proc	access:public
proc	proc.h	/^struct proc {$/;"	s
proc::alarmhandler	proc.h	/^  void (*alarmhandler)();      \/\/ hw5 alarmhandler$/;"	m	struct:proc	access:public
proc::alarmticks	proc.h	/^  int alarmticks;              \/\/ hw5 alarmticks$/;"	m	struct:proc	access:public
proc::chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc	access:public
proc::context	proc.h	/^  struct context *context;     \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context	access:public
proc::cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode	access:public
proc::killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc	access:public
proc::kstack	proc.h	/^  char *kstack;                \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc	access:public
proc::name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc	access:public
proc::ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file	access:public
proc::parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc	access:public
proc::pgdir	proc.h	/^  pde_t* pgdir;                \/\/ Page table$/;"	m	struct:proc	access:public
proc::pid	proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc	access:public
proc::state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate	access:public
proc::sz	proc.h	/^  uint sz;                     \/\/ Size of process memory (bytes)$/;"	m	struct:proc	access:public
proc::tf	proc.h	/^  struct trapframe *tf;        \/\/ Trap frame for current syscall$/;"	m	struct:proc	typeref:struct:proc::trapframe	access:public
proc::tickspassed	proc.h	/^  int tickspassed;             \/\/ hw5 alarmticks passed$/;"	m	struct:proc	access:public
procdump	defs.h	/^void            procdump(void);$/;"	p	signature:(void)
procdump	proc.c	/^procdump(void)$/;"	f	signature:(void)
procstate	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
product	mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf	access:public
proghdr	elf.h	/^struct proghdr {$/;"	s
proghdr::align	elf.h	/^  uint align;$/;"	m	struct:proghdr	access:public
proghdr::filesz	elf.h	/^  uint filesz;$/;"	m	struct:proghdr	access:public
proghdr::flags	elf.h	/^  uint flags;$/;"	m	struct:proghdr	access:public
proghdr::memsz	elf.h	/^  uint memsz;$/;"	m	struct:proghdr	access:public
proghdr::off	elf.h	/^  uint off;$/;"	m	struct:proghdr	access:public
proghdr::paddr	elf.h	/^  uint paddr;$/;"	m	struct:proghdr	access:public
proghdr::type	elf.h	/^  uint type;$/;"	m	struct:proghdr	access:public
proghdr::vaddr	elf.h	/^  uint vaddr;$/;"	m	struct:proghdr	access:public
ptable	proc.c	/^} ptable;$/;"	v	typeref:struct:__anon4
pte_t	mmu.h	/^typedef uint pte_t;$/;"	t
ptr	umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon6	typeref:union:header::__anon6::header	file:	access:public
pushcli	defs.h	/^void            pushcli(void);$/;"	p	signature:(void)
pushcli	spinlock.c	/^pushcli(void)$/;"	f	signature:(void)
putc	printf.c	/^putc(int fd, char c)$/;"	f	file:	signature:(int fd, char c)
qnext	buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf	access:public
r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon3	file:	access:public
rand	usertests.c	/^rand()$/;"	f
randstate	usertests.c	/^unsigned long randstate = 1;$/;"	v
rcr2	x86.h	/^rcr2(void)$/;"	f	signature:(void)
read	file.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
read	file_bak.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
read	user.h	/^int read(int, void*, int);$/;"	p	signature:(int, void*, int)
read_head	log.c	/^read_head(void)$/;"	f	file:	signature:(void)
read_head	log_bak.c	/^read_head(void)$/;"	f	file:	signature:(void)
readable	file.h	/^  char readable;$/;"	m	struct:file	access:public
readable	file_bak.h	/^  char readable;$/;"	m	struct:file	access:public
readeflags	x86.h	/^readeflags(void)$/;"	f	signature:(void)
readi	defs.h	/^int             readi(struct inode*, char*, uint, uint);$/;"	p	signature:(struct inode*, char*, uint, uint)
readi	fs.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f	signature:(struct inode *ip, char *dst, uint off, uint n)
readi	fs_bak.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f	signature:(struct inode *ip, char *dst, uint off, uint n)
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:	access:public
readsb	defs.h	/^void            readsb(int dev, struct superblock *sb);$/;"	p	signature:(int dev, struct superblock *sb)
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f	signature:(int dev, struct superblock *sb)
readsb	fs_bak.c	/^readsb(int dev, struct superblock *sb)$/;"	f	signature:(int dev, struct superblock *sb)
readsect	bootmain.c	/^readsect(void *dst, uint offset)$/;"	f	signature:(void *dst, uint offset)
readseg	bootmain.c	/^readseg(uchar* pa, uint count, uint offset)$/;"	f	signature:(uchar* pa, uint count, uint offset)
readseg	bootmain.c	/^void readseg(uchar*, uint, uint);$/;"	p	file:	signature:(uchar*, uint, uint)
recover_from_log	log.c	/^recover_from_log(void)$/;"	f	file:	signature:(void)
recover_from_log	log.c	/^static void recover_from_log(void);$/;"	p	file:	signature:(void)
recover_from_log	log_bak.c	/^recover_from_log(void)$/;"	f	file:	signature:(void)
recover_from_log	log_bak.c	/^static void recover_from_log(void);$/;"	p	file:	signature:(void)
redircmd	sh.c	/^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$/;"	f	signature:(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
redircmd	sh.c	/^struct redircmd {$/;"	s	file:
redircmd::cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:	access:public
redircmd::efile	sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:	access:public
redircmd::fd	sh.c	/^  int fd;$/;"	m	struct:redircmd	file:	access:public
redircmd::file	sh.c	/^  char *file;$/;"	m	struct:redircmd	file:	access:public
redircmd::mode	sh.c	/^  int mode;$/;"	m	struct:redircmd	file:	access:public
redircmd::type	sh.c	/^  int type;$/;"	m	struct:redircmd	file:	access:public
ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode	access:public
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file	access:public
ref	file_bak.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode	access:public
ref	file_bak.h	/^  int ref; \/\/ reference count$/;"	m	struct:file	access:public
refcnt	buf.h	/^  uint refcnt;$/;"	m	struct:buf	access:public
reg	ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:	access:public
release	defs.h	/^void            release(struct spinlock*);$/;"	p	signature:(struct spinlock*)
release	spinlock.c	/^release(struct spinlock *lk)$/;"	f	signature:(struct spinlock *lk)
releasesleep	defs.h	/^void            releasesleep(struct sleeplock*);$/;"	p	signature:(struct sleeplock*)
releasesleep	sleeplock.c	/^releasesleep(struct sleeplock *lk)$/;"	f	signature:(struct sleeplock *lk)
reserved	mp.h	/^  uchar reserved;$/;"	m	struct:mpconf	access:public
reserved	mp.h	/^  uchar reserved[3];$/;"	m	struct:mp	access:public
reserved	mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc	access:public
right	sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:	access:public
right	sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:	access:public
rinode	mkfs.c	/^rinode(uint inum, struct dinode *ip)$/;"	f	signature:(uint inum, struct dinode *ip)
rinode	mkfs.c	/^void rinode(uint inum, struct dinode *ip);$/;"	p	file:	signature:(uint inum, struct dinode *ip)
rmdot	usertests.c	/^rmdot(void)$/;"	f	signature:(void)
rsect	mkfs.c	/^rsect(uint sec, void *buf)$/;"	f	signature:(uint sec, void *buf)
rsect	mkfs.c	/^void rsect(uint sec, void *buf);$/;"	p	file:	signature:(uint sec, void *buf)
rsv1	mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc	access:public
rsv1	mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc	access:public
rtcdate	date.h	/^struct rtcdate {$/;"	s
rtcdate::day	date.h	/^  uint day;$/;"	m	struct:rtcdate	access:public
rtcdate::hour	date.h	/^  uint hour;$/;"	m	struct:rtcdate	access:public
rtcdate::minute	date.h	/^  uint minute;$/;"	m	struct:rtcdate	access:public
rtcdate::month	date.h	/^  uint month;$/;"	m	struct:rtcdate	access:public
rtcdate::second	date.h	/^  uint second;$/;"	m	struct:rtcdate	access:public
rtcdate::year	date.h	/^  uint year;$/;"	m	struct:rtcdate	access:public
run	kalloc.c	/^struct run {$/;"	s	file:
run::next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:	access:public
runcmd	sh.c	/^runcmd(struct cmd *cmd)$/;"	f	signature:(struct cmd *cmd)
s	mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc	access:public
s	mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc	access:public
s	umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon6	file:	access:public
safestrcpy	defs.h	/^char*           safestrcpy(char*, const char*, int);$/;"	p	signature:(char*, const char*, int)
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f	signature:(char *s, const char *t, int n)
sb	fs.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sb	fs_bak.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sb	mkfs.c	/^struct superblock sb;$/;"	v	typeref:struct:superblock
sbrk	user.h	/^char* sbrk(int);$/;"	p	signature:(int)
sbrktest	usertests.c	/^sbrktest(void)$/;"	f	signature:(void)
sched	defs.h	/^void            sched(void);$/;"	p	signature:(void)
sched	proc.c	/^sched(void)$/;"	f	signature:(void)
scheduler	defs.h	/^void            scheduler(void) __attribute__((noreturn));$/;"	p	signature:(void)
scheduler	proc.c	/^scheduler(void)$/;"	f	signature:(void)
scheduler	proc.h	/^  struct context *scheduler;   \/\/ swtch() here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context	access:public
second	date.h	/^  uint second;$/;"	m	struct:rtcdate	access:public
segdesc	mmu.h	/^struct segdesc {$/;"	s
segdesc::avl	mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc	access:public
segdesc::base_15_0	mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc	access:public
segdesc::base_23_16	mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc	access:public
segdesc::base_31_24	mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc	access:public
segdesc::db	mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc	access:public
segdesc::dpl	mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc	access:public
segdesc::g	mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc	access:public
segdesc::lim_15_0	mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc	access:public
segdesc::lim_19_16	mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc	access:public
segdesc::p	mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc	access:public
segdesc::rsv1	mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc	access:public
segdesc::s	mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc	access:public
segdesc::type	mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc	access:public
seginit	defs.h	/^void            seginit(void);$/;"	p	signature:(void)
seginit	vm.c	/^seginit(void)$/;"	f	signature:(void)
setproc	defs.h	/^void            setproc(struct proc*);$/;"	p	signature:(struct proc*)
setupkvm	defs.h	/^pde_t*          setupkvm(void);$/;"	p	signature:(void)
setupkvm	vm.c	/^setupkvm(void)$/;"	f	signature:(void)
sharedfd	usertests.c	/^sharedfd(void)$/;"	f	signature:(void)
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr	access:public
shiftcode	kbd.h	/^static uchar shiftcode[256] =$/;"	v
shiftmap	kbd.h	/^static uchar shiftmap[256] =$/;"	v
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr	access:public
shoff	elf.h	/^  uint shoff;$/;"	m	struct:elfhdr	access:public
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr	access:public
signature	mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf	access:public
signature	mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp	access:public
signature	mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc	access:public
size	file.h	/^  uint size;$/;"	m	struct:inode	access:public
size	file_bak.h	/^  uint size;$/;"	m	struct:inode	access:public
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode	access:public
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock	access:public
size	fs_bak.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode	access:public
size	fs_bak.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock	access:public
size	log.c	/^  int size;$/;"	m	struct:log	file:	access:public
size	log_bak.c	/^  int size;$/;"	m	struct:log	file:	access:public
size	stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat	access:public
size	umalloc.c	/^    uint size;$/;"	m	struct:header::__anon6	file:	access:public
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	file:	signature:(char *path, char *name)
skipelem	fs_bak.c	/^skipelem(char *path, char *name)$/;"	f	file:	signature:(char *path, char *name)
sleep	defs.h	/^void            sleep(void*, struct spinlock*);$/;"	p	signature:(void*, struct spinlock*)
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f	signature:(void *chan, struct spinlock *lk)
sleep	user.h	/^int sleep(int);$/;"	p	signature:(int)
sleeplock	sleeplock.h	/^struct sleeplock {$/;"	s
sleeplock::lk	sleeplock.h	/^  struct spinlock lk; \/\/ spinlock protecting this sleep lock$/;"	m	struct:sleeplock	typeref:struct:sleeplock::spinlock	access:public
sleeplock::locked	sleeplock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:sleeplock	access:public
sleeplock::name	sleeplock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:sleeplock	access:public
sleeplock::pid	sleeplock.h	/^  int pid;           \/\/ Process holding lock$/;"	m	struct:sleeplock	access:public
sp	uthread.c	/^  int        sp;                \/* saved stack pointer *\/$/;"	m	struct:thread	file:	access:public
specrev	mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp	access:public
spin	bootasm.S	/^spin:$/;"	l
spin	entryother.S	/^spin:$/;"	l
spinlock	spinlock.h	/^struct spinlock {$/;"	s
spinlock::cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu	access:public
spinlock::locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock	access:public
spinlock::name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock	access:public
spinlock::pcs	spinlock.h	/^  uint pcs[10];      \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock	access:public
ss	mmu.h	/^  ushort ss;$/;"	m	struct:taskstate	access:public
ss	x86.h	/^  ushort ss;$/;"	m	struct:trapframe	access:public
ss0	mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate	access:public
ss1	mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate	access:public
ss2	mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate	access:public
stack	uthread.c	/^  char stack[STACK_SIZE];       \/* the thread's stack *\/$/;"	m	struct:thread	file:	access:public
start	bootasm.S	/^start:$/;"	l
start	entryother.S	/^start:$/;"	l
start	initcode.S	/^start:$/;"	l
start	log.c	/^  int start;$/;"	m	struct:log	file:	access:public
start	log_bak.c	/^  int start;$/;"	m	struct:log	file:	access:public
start32	bootasm.S	/^start32:$/;"	l
start32	entryother.S	/^start32:$/;"	l
started	proc.h	/^  volatile uint started;       \/\/ Has the CPU started?$/;"	m	struct:cpu	access:public
startothers	main.c	/^startothers(void)$/;"	f	file:	signature:(void)
startothers	main.c	/^static void startothers(void);$/;"	p	file:	signature:(void)
stat	mkfs.c	8;"	d	file:
stat	stat.h	/^struct stat {$/;"	s
stat	ulib.c	/^stat(const char *n, struct stat *st)$/;"	f	signature:(const char *n, struct stat *st)
stat	user.h	/^int stat(const char*, struct stat*);$/;"	p	signature:(const char*, struct stat*)
stat::dev	stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat	access:public
stat::ino	stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat	access:public
stat::nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat	access:public
stat::size	stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat	access:public
stat::type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat	access:public
state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate	access:public
state	uthread.c	/^  int        state;             \/* FREE, RUNNING, RUNNABLE *\/$/;"	m	struct:thread	file:	access:public
stati	defs.h	/^void            stati(struct inode*, struct stat*);$/;"	p	signature:(struct inode*, struct stat*)
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f	signature:(struct inode *ip, struct stat *st)
stati	fs_bak.c	/^stati(struct inode *ip, struct stat *st)$/;"	f	signature:(struct inode *ip, struct stat *st)
static_assert	mkfs.c	15;"	d	file:
stdout	usertests.c	/^int stdout = 1;$/;"	v
sti	x86.h	/^sti(void)$/;"	f	signature:(void)
stosb	x86.h	/^stosb(void *addr, int data, int cnt)$/;"	f	signature:(void *addr, int data, int cnt)
stosl	x86.h	/^stosl(void *addr, int data, int cnt)$/;"	f	signature:(void *addr, int data, int cnt)
strchr	ulib.c	/^strchr(const char *s, char c)$/;"	f	signature:(const char *s, char c)
strchr	user.h	/^char* strchr(const char*, char c);$/;"	p	signature:(const char*, char c)
strcmp	ulib.c	/^strcmp(const char *p, const char *q)$/;"	f	signature:(const char *p, const char *q)
strcmp	user.h	/^int strcmp(const char*, const char*);$/;"	p	signature:(const char*, const char*)
strcpy	ulib.c	/^strcpy(char *s, const char *t)$/;"	f	signature:(char *s, const char *t)
strcpy	user.h	/^char* strcpy(char*, const char*);$/;"	p	signature:(char*, const char*)
strlen	defs.h	/^int             strlen(const char*);$/;"	p	signature:(const char*)
strlen	string.c	/^strlen(const char *s)$/;"	f	signature:(const char *s)
strlen	ulib.c	/^strlen(const char *s)$/;"	f	signature:(const char *s)
strlen	user.h	/^uint strlen(const char*);$/;"	p	signature:(const char*)
strncmp	defs.h	/^int             strncmp(const char*, const char*, uint);$/;"	p	signature:(const char*, const char*, uint)
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f	signature:(const char *p, const char *q, uint n)
strncpy	defs.h	/^char*           strncpy(char*, const char*, int);$/;"	p	signature:(char*, const char*, int)
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f	signature:(char *s, const char *t, int n)
subdir	usertests.c	/^subdir(void)$/;"	f	signature:(void)
sum	mp.c	/^sum(uchar *addr, int len)$/;"	f	file:	signature:(uchar *addr, int len)
superblock	fs.h	/^struct superblock {$/;"	s
superblock	fs_bak.h	/^struct superblock {$/;"	s
superblock::bmapstart	fs.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock	access:public
superblock::bmapstart	fs_bak.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock	access:public
superblock::inodestart	fs.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock	access:public
superblock::inodestart	fs_bak.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock	access:public
superblock::logstart	fs.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock	access:public
superblock::logstart	fs_bak.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock	access:public
superblock::nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock	access:public
superblock::nblocks	fs_bak.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock	access:public
superblock::ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock	access:public
superblock::ninodes	fs_bak.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock	access:public
superblock::nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock	access:public
superblock::nlog	fs_bak.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock	access:public
superblock::size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock	access:public
superblock::size	fs_bak.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock	access:public
switchkvm	defs.h	/^void            switchkvm(void);$/;"	p	signature:(void)
switchkvm	vm.c	/^switchkvm(void)$/;"	f	signature:(void)
switchuvm	defs.h	/^void            switchuvm(struct proc*);$/;"	p	signature:(struct proc*)
switchuvm	vm.c	/^switchuvm(struct proc *p)$/;"	f	signature:(struct proc *p)
swtch	defs.h	/^void            swtch(struct context**, struct context*);$/;"	p	signature:(struct context**, struct context*)
swtch	swtch.S	/^swtch:$/;"	l
symbols	sh.c	/^char symbols[] = "<|>&;()";$/;"	v
sys_alarm	syscall.c	/^extern int sys_alarm(void);$/;"	p	file:	signature:(void)
sys_alarm	sysproc.c	/^int sys_alarm(void){$/;"	f	signature:(void)
sys_chdir	syscall.c	/^extern int sys_chdir(void);$/;"	p	file:	signature:(void)
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f	signature:(void)
sys_close	syscall.c	/^extern int sys_close(void);$/;"	p	file:	signature:(void)
sys_close	sysfile.c	/^sys_close(void)$/;"	f	signature:(void)
sys_date	syscall.c	/^extern int sys_date(void);$/;"	p	file:	signature:(void)
sys_date	sysproc.c	/^int sys_date(void){$/;"	f	signature:(void)
sys_dup	syscall.c	/^extern int sys_dup(void);$/;"	p	file:	signature:(void)
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f	signature:(void)
sys_exec	syscall.c	/^extern int sys_exec(void);$/;"	p	file:	signature:(void)
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f	signature:(void)
sys_exit	syscall.c	/^extern int sys_exit(void);$/;"	p	file:	signature:(void)
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f	signature:(void)
sys_fork	syscall.c	/^extern int sys_fork(void);$/;"	p	file:	signature:(void)
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f	signature:(void)
sys_fstat	syscall.c	/^extern int sys_fstat(void);$/;"	p	file:	signature:(void)
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f	signature:(void)
sys_getpid	syscall.c	/^extern int sys_getpid(void);$/;"	p	file:	signature:(void)
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f	signature:(void)
sys_kill	syscall.c	/^extern int sys_kill(void);$/;"	p	file:	signature:(void)
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f	signature:(void)
sys_link	syscall.c	/^extern int sys_link(void);$/;"	p	file:	signature:(void)
sys_link	sysfile.c	/^sys_link(void)$/;"	f	signature:(void)
sys_mkdir	syscall.c	/^extern int sys_mkdir(void);$/;"	p	file:	signature:(void)
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f	signature:(void)
sys_mknod	syscall.c	/^extern int sys_mknod(void);$/;"	p	file:	signature:(void)
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f	signature:(void)
sys_open	syscall.c	/^extern int sys_open(void);$/;"	p	file:	signature:(void)
sys_open	sysfile.c	/^sys_open(void)$/;"	f	signature:(void)
sys_pipe	syscall.c	/^extern int sys_pipe(void);$/;"	p	file:	signature:(void)
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f	signature:(void)
sys_read	syscall.c	/^extern int sys_read(void);$/;"	p	file:	signature:(void)
sys_read	sysfile.c	/^sys_read(void)$/;"	f	signature:(void)
sys_sbrk	syscall.c	/^extern int sys_sbrk(void);$/;"	p	file:	signature:(void)
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f	signature:(void)
sys_sleep	syscall.c	/^extern int sys_sleep(void);$/;"	p	file:	signature:(void)
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f	signature:(void)
sys_unlink	syscall.c	/^extern int sys_unlink(void);$/;"	p	file:	signature:(void)
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f	signature:(void)
sys_uptime	syscall.c	/^extern int sys_uptime(void);$/;"	p	file:	signature:(void)
sys_uptime	sysproc.c	/^sys_uptime(void)$/;"	f	signature:(void)
sys_wait	syscall.c	/^extern int sys_wait(void);$/;"	p	file:	signature:(void)
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f	signature:(void)
sys_write	syscall.c	/^extern int sys_write(void);$/;"	p	file:	signature:(void)
sys_write	sysfile.c	/^sys_write(void)$/;"	f	signature:(void)
syscall	defs.h	/^void            syscall(void);$/;"	p	signature:(void)
syscall	syscall.c	/^syscall(void)$/;"	f	signature:(void)
syscalls	syscall.c	/^static int (*syscalls[])(void) = {$/;"	v	file:
sz	proc.h	/^  uint sz;                     \/\/ Size of process memory (bytes)$/;"	m	struct:proc	access:public
t	mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate	access:public
taskstate	mmu.h	/^struct taskstate {$/;"	s
taskstate::cr3	mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate	access:public
taskstate::cs	mmu.h	/^  ushort cs;$/;"	m	struct:taskstate	access:public
taskstate::ds	mmu.h	/^  ushort ds;$/;"	m	struct:taskstate	access:public
taskstate::eax	mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate	access:public
taskstate::ebp	mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate	access:public
taskstate::ebx	mmu.h	/^  uint ebx;$/;"	m	struct:taskstate	access:public
taskstate::ecx	mmu.h	/^  uint ecx;$/;"	m	struct:taskstate	access:public
taskstate::edi	mmu.h	/^  uint edi;$/;"	m	struct:taskstate	access:public
taskstate::edx	mmu.h	/^  uint edx;$/;"	m	struct:taskstate	access:public
taskstate::eflags	mmu.h	/^  uint eflags;$/;"	m	struct:taskstate	access:public
taskstate::eip	mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate	access:public
taskstate::es	mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate	access:public
taskstate::esi	mmu.h	/^  uint esi;$/;"	m	struct:taskstate	access:public
taskstate::esp	mmu.h	/^  uint *esp;$/;"	m	struct:taskstate	access:public
taskstate::esp0	mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate	access:public
taskstate::esp1	mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate	access:public
taskstate::esp2	mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate	access:public
taskstate::fs	mmu.h	/^  ushort fs;$/;"	m	struct:taskstate	access:public
taskstate::gs	mmu.h	/^  ushort gs;$/;"	m	struct:taskstate	access:public
taskstate::iomb	mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate	access:public
taskstate::ldt	mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate	access:public
taskstate::link	mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate	access:public
taskstate::padding1	mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate	access:public
taskstate::padding10	mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate	access:public
taskstate::padding2	mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate	access:public
taskstate::padding3	mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate	access:public
taskstate::padding4	mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate	access:public
taskstate::padding5	mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate	access:public
taskstate::padding6	mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate	access:public
taskstate::padding7	mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate	access:public
taskstate::padding8	mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate	access:public
taskstate::padding9	mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate	access:public
taskstate::ss	mmu.h	/^  ushort ss;$/;"	m	struct:taskstate	access:public
taskstate::ss0	mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate	access:public
taskstate::ss1	mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate	access:public
taskstate::ss2	mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate	access:public
taskstate::t	mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate	access:public
tf	proc.h	/^  struct trapframe *tf;        \/\/ Trap frame for current syscall$/;"	m	struct:proc	typeref:struct:proc::trapframe	access:public
thread	uthread.c	/^struct thread {$/;"	s	file:
thread::sp	uthread.c	/^  int        sp;                \/* saved stack pointer *\/$/;"	m	struct:thread	file:	access:public
thread::stack	uthread.c	/^  char stack[STACK_SIZE];       \/* the thread's stack *\/$/;"	m	struct:thread	file:	access:public
thread::state	uthread.c	/^  int        state;             \/* FREE, RUNNING, RUNNABLE *\/$/;"	m	struct:thread	file:	access:public
thread_create	uthread.c	/^thread_create(void (*func)())$/;"	f	signature:(void (*func)())
thread_init	uthread.c	/^thread_init(void)$/;"	f	signature:(void)
thread_p	uthread.c	/^typedef struct thread thread_t, *thread_p;$/;"	t	typeref:struct:	file:
thread_schedule	uthread.c	/^thread_schedule(void)$/;"	f	file:	signature:(void)
thread_switch	uthread.c	/^extern void thread_switch(void);$/;"	p	file:	signature:(void)
thread_switch	uthread_switch.S	/^thread_switch:$/;"	l
thread_t	uthread.c	/^typedef struct thread thread_t, *thread_p;$/;"	t	typeref:struct:thread	file:
thread_yield	uthread.c	/^thread_yield(void)$/;"	f	signature:(void)
ticks	trap.c	/^uint ticks;$/;"	v
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
tickspassed	proc.h	/^  int tickspassed;             \/\/ hw5 alarmticks passed$/;"	m	struct:proc	access:public
timerinit	defs.h	/^void            timerinit(void);$/;"	p	signature:(void)
togglecode	kbd.h	/^static uchar togglecode[256] =$/;"	v
trap	trap.c	/^trap(struct trapframe *tf)$/;"	f	signature:(struct trapframe *tf)
trapframe	x86.h	/^struct trapframe {$/;"	s
trapframe::cs	x86.h	/^  ushort cs;$/;"	m	struct:trapframe	access:public
trapframe::ds	x86.h	/^  ushort ds;$/;"	m	struct:trapframe	access:public
trapframe::eax	x86.h	/^  uint eax;$/;"	m	struct:trapframe	access:public
trapframe::ebp	x86.h	/^  uint ebp;$/;"	m	struct:trapframe	access:public
trapframe::ebx	x86.h	/^  uint ebx;$/;"	m	struct:trapframe	access:public
trapframe::ecx	x86.h	/^  uint ecx;$/;"	m	struct:trapframe	access:public
trapframe::edi	x86.h	/^  uint edi;$/;"	m	struct:trapframe	access:public
trapframe::edx	x86.h	/^  uint edx;$/;"	m	struct:trapframe	access:public
trapframe::eflags	x86.h	/^  uint eflags;$/;"	m	struct:trapframe	access:public
trapframe::eip	x86.h	/^  uint eip;$/;"	m	struct:trapframe	access:public
trapframe::err	x86.h	/^  uint err;$/;"	m	struct:trapframe	access:public
trapframe::es	x86.h	/^  ushort es;$/;"	m	struct:trapframe	access:public
trapframe::esi	x86.h	/^  uint esi;$/;"	m	struct:trapframe	access:public
trapframe::esp	x86.h	/^  uint esp;$/;"	m	struct:trapframe	access:public
trapframe::fs	x86.h	/^  ushort fs;$/;"	m	struct:trapframe	access:public
trapframe::gs	x86.h	/^  ushort gs;$/;"	m	struct:trapframe	access:public
trapframe::oesp	x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe	access:public
trapframe::padding1	x86.h	/^  ushort padding1;$/;"	m	struct:trapframe	access:public
trapframe::padding2	x86.h	/^  ushort padding2;$/;"	m	struct:trapframe	access:public
trapframe::padding3	x86.h	/^  ushort padding3;$/;"	m	struct:trapframe	access:public
trapframe::padding4	x86.h	/^  ushort padding4;$/;"	m	struct:trapframe	access:public
trapframe::padding5	x86.h	/^  ushort padding5;$/;"	m	struct:trapframe	access:public
trapframe::padding6	x86.h	/^  ushort padding6;$/;"	m	struct:trapframe	access:public
trapframe::ss	x86.h	/^  ushort ss;$/;"	m	struct:trapframe	access:public
trapframe::trapno	x86.h	/^  uint trapno;$/;"	m	struct:trapframe	access:public
trapno	x86.h	/^  uint trapno;$/;"	m	struct:trapframe	access:public
trapret	proc.c	/^extern void trapret(void);$/;"	p	file:	signature:(void)
trapret	trapasm.S	/^trapret:$/;"	l
ts	proc.h	/^  struct taskstate ts;         \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate	access:public
tvinit	defs.h	/^void            tvinit(void);$/;"	p	signature:(void)
tvinit	trap.c	/^tvinit(void)$/;"	f	signature:(void)
type	elf.h	/^  uint type;$/;"	m	struct:proghdr	access:public
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr	access:public
type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon8	access:public
type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode	access:public
type	file_bak.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon5	access:public
type	file_bak.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode	access:public
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode	access:public
type	fs_bak.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode	access:public
type	mmu.h	/^  uint type : 4;        \/\/ type(STS_{IG32,TG32})$/;"	m	struct:gatedesc	access:public
type	mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc	access:public
type	mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp	access:public
type	mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc	access:public
type	mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic	access:public
type	sh.c	/^  int type;$/;"	m	struct:backcmd	file:	access:public
type	sh.c	/^  int type;$/;"	m	struct:cmd	file:	access:public
type	sh.c	/^  int type;$/;"	m	struct:execcmd	file:	access:public
type	sh.c	/^  int type;$/;"	m	struct:listcmd	file:	access:public
type	sh.c	/^  int type;$/;"	m	struct:pipecmd	file:	access:public
type	sh.c	/^  int type;$/;"	m	struct:redircmd	file:	access:public
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat	access:public
uart	uart.c	/^static int uart;    \/\/ is there a uart?$/;"	v	file:
uartgetc	uart.c	/^uartgetc(void)$/;"	f	file:	signature:(void)
uartinit	defs.h	/^void            uartinit(void);$/;"	p	signature:(void)
uartinit	uart.c	/^uartinit(void)$/;"	f	signature:(void)
uartintr	defs.h	/^void            uartintr(void);$/;"	p	signature:(void)
uartintr	uart.c	/^uartintr(void)$/;"	f	signature:(void)
uartputc	defs.h	/^void            uartputc(int);$/;"	p	signature:(int)
uartputc	uart.c	/^uartputc(int c)$/;"	f	signature:(int c)
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t
uint	types.h	/^typedef unsigned int   uint;$/;"	t
uio	usertests.c	/^uio()$/;"	f
uninit	usertests.c	/^char uninit[10000];$/;"	v
unlink	user.h	/^int unlink(const char*);$/;"	p	signature:(const char*)
unlinkread	usertests.c	/^unlinkread(void)$/;"	f	signature:(void)
uptime	user.h	/^int uptime(void);$/;"	p	signature:(void)
use_lock	kalloc.c	/^  int use_lock;$/;"	m	struct:__anon1	file:	access:public
userinit	defs.h	/^void            userinit(void);$/;"	p	signature:(void)
userinit	proc.c	/^userinit(void)$/;"	f	signature:(void)
ushort	types.h	/^typedef unsigned short ushort;$/;"	t
uva2ka	defs.h	/^char*           uva2ka(pde_t*, char*);$/;"	p	signature:(pde_t*, char*)
uva2ka	vm.c	/^uva2ka(pde_t *pgdir, char *uva)$/;"	f	signature:(pde_t *pgdir, char *uva)
vaddr	elf.h	/^  uint vaddr;$/;"	m	struct:proghdr	access:public
valid	file.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode	access:public
valid	file_bak.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode	access:public
validateint	usertests.c	/^validateint(int *p)$/;"	f	signature:(int *p)
validatetest	usertests.c	/^validatetest(void)$/;"	f	signature:(void)
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr	access:public
version	mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic	access:public
version	mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf	access:public
version	mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc	access:public
virt	vm.c	/^  void *virt;$/;"	m	struct:kmap	file:	access:public
w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon3	file:	access:public
wait	defs.h	/^int             wait(void);$/;"	p	signature:(void)
wait	proc.c	/^wait(void)$/;"	f	signature:(void)
wait	user.h	/^int wait(void);$/;"	p	signature:(void)
waitdisk	bootmain.c	/^waitdisk(void)$/;"	f	signature:(void)
wakeup	defs.h	/^void            wakeup(void*);$/;"	p	signature:(void*)
wakeup	proc.c	/^wakeup(void *chan)$/;"	f	signature:(void *chan)
wakeup1	proc.c	/^static void wakeup1(void *chan);$/;"	p	file:	signature:(void *chan)
wakeup1	proc.c	/^wakeup1(void *chan)$/;"	f	file:	signature:(void *chan)
walkpgdir	vm.c	/^walkpgdir(pde_t *pgdir, const void *va, int alloc)$/;"	f	file:	signature:(pde_t *pgdir, const void *va, int alloc)
wc	wc.c	/^wc(int fd, char *name)$/;"	f	signature:(int fd, char *name)
whitespace	sh.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
winode	mkfs.c	/^void winode(uint, struct dinode*);$/;"	p	file:	signature:(uint, struct dinode*)
winode	mkfs.c	/^winode(uint inum, struct dinode *ip)$/;"	f	signature:(uint inum, struct dinode *ip)
writable	file.h	/^  char writable;$/;"	m	struct:file	access:public
writable	file_bak.h	/^  char writable;$/;"	m	struct:file	access:public
write	file.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
write	file_bak.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw	access:public
write	user.h	/^int write(int, const void*, int);$/;"	p	signature:(int, const void*, int)
write_head	log.c	/^write_head(void)$/;"	f	file:	signature:(void)
write_head	log_bak.c	/^write_head(void)$/;"	f	file:	signature:(void)
write_log	log.c	/^write_log(void)$/;"	f	file:	signature:(void)
write_log	log_bak.c	/^write_log(void)$/;"	f	file:	signature:(void)
writefile	cuth	/^sub writefile($@){$/;"	s
writei	defs.h	/^int             writei(struct inode*, char*, uint, uint);$/;"	p	signature:(struct inode*, char*, uint, uint)
writei	fs.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f	signature:(struct inode *ip, char *src, uint off, uint n)
writei	fs_bak.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f	signature:(struct inode *ip, char *src, uint off, uint n)
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:	access:public
writetest	usertests.c	/^writetest(void)$/;"	f	signature:(void)
writetest1	usertests.c	/^writetest1(void)$/;"	f	signature:(void)
wsect	mkfs.c	/^void wsect(uint, void*);$/;"	p	file:	signature:(uint, void*)
wsect	mkfs.c	/^wsect(uint sec, void *buf)$/;"	f	signature:(uint sec, void *buf)
x	umalloc.c	/^  Align x;$/;"	m	union:header	file:	access:public
xchecksum	mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf	access:public
xchg	x86.h	/^xchg(volatile uint *addr, uint newval)$/;"	f	signature:(volatile uint *addr, uint newval)
xint	mkfs.c	/^xint(uint x)$/;"	f	signature:(uint x)
xlength	mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf	access:public
xshort	mkfs.c	/^xshort(ushort x)$/;"	f	signature:(ushort x)
year	date.h	/^  uint year;$/;"	m	struct:rtcdate	access:public
yield	defs.h	/^void            yield(void);$/;"	p	signature:(void)
yield	proc.c	/^yield(void)$/;"	f	signature:(void)
zeroes	mkfs.c	/^char zeroes[BSIZE];$/;"	v
